<!DOCTYPE html>
<html lang="en">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="google-site-verification" content="xBT4GhYoi5qRD5tr338pgPM5OWHHIDR6mNg1a3euekI">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="FlowerMushroom的博客">
    <meta name="keyword" content>
    <link rel="shortcut icon" href="/img/favicon.ico">

    <title>
        
        初学python2.7（九）类 - FlowerMushroom的博客 | FlowerMushroom&#39;s Blog
        
    </title>

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/aircloud.css">
    <link rel="stylesheet" href="/css/gitment.css">
    <!--<link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css">-->
    <link href="//at.alicdn.com/t/font_620856_pl6z7sid89qkt9.css" rel="stylesheet" type="text/css">
    <!-- ga & ba script hoook -->
    <script></script>
</head>

<body>

<div class="site-nav-toggle" id="site-nav-toggle">
    <button>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
        <span class="btn-bar"></span>
    </button>
</div>

<div class="index-about">
    <i> 拂水飘绵送行色 应折柔条过千枝 </i>
</div>

<div class="index-container">
    
    <div class="index-left">
        
<div class="nav" id="nav">
    <div class="avatar-name">
        <div class="avatar ">
            <img src="/images/head.jpg" />
        </div>
        <div class="name">
            <i>FlowerMushroom</i>
        </div>
    </div>
    <div class="contents" id="nav-content">
        <ul>
            <li >
                <a href="/">
                    <i class="iconfont icon-shouye1"></i>
                    <span>主页</span>
                </a>
            </li>
            <li >
                <a href="/tags">
                    <i class="iconfont icon-biaoqian1"></i>
                    <span>标签</span>
                </a>
            </li>
            <li >
                <a href="/archive">
                    <i class="iconfont icon-guidang2"></i>
                    <span>存档</span>
                </a>
            </li>
            <li >
                <a href="/about/">
                    <i class="iconfont icon-guanyu2"></i>
                    <span>关于</span>
                </a>
            </li>
            
            <li>
                <a id="search">
                    <i class="iconfont icon-sousuo1"></i>
                    <span>搜索</span>
                </a>
            </li>
            
        </ul>
    </div>
    
        <div id="toc" class="toc-article">
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#类Class"><span class="toc-text">类Class</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1-名称Name和对象Object"><span class="toc-text">9.1 名称Name和对象Object</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-作用域Scope和命名空间Namespace"><span class="toc-text">9.2 作用域Scope和命名空间Namespace</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-3-初探类Class"><span class="toc-text">9.3 初探类Class</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-1-类定义语法Class-Definition-Syntax"><span class="toc-text">9.3.1 类定义语法Class Definition Syntax</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-2-类对象Class-Object"><span class="toc-text">9.3.2 类对象Class Object</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-1-属性引用"><span class="toc-text">9.3.2.1 属性引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-3-2-2-实例化"><span class="toc-text">9.3.2.2 实例化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-3-实例对象"><span class="toc-text">9.3.3 实例对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-4-方法对象Method-Object"><span class="toc-text">9.3.4 方法对象Method Object</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-3-5-类和实例变量Instance-Variable"><span class="toc-text">9.3.5 类和实例变量Instance Variable</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-4-补充说明"><span class="toc-text">9.4 补充说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-5-继承Inheritance"><span class="toc-text">9.5 继承Inheritance</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-5-1-多重继承Multiple-Inheritance"><span class="toc-text">9.5.1 多重继承Multiple Inheritance</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-6-私有变量Private-Variables和类局部引用Class-local-References"><span class="toc-text">9.6 私有变量Private Variables和类局部引用Class-local References</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-6-1-名称改写name-mangling"><span class="toc-text">9.6.1 名称改写name mangling</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-7-杂项说明"><span class="toc-text">9.7 杂项说明</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-8-异常Exception是类"><span class="toc-text">9.8 异常Exception是类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-9-迭代器Iterator"><span class="toc-text">9.9 迭代器Iterator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-10-生成器Generator"><span class="toc-text">9.10 生成器Generator</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-11-生成器表达式"><span class="toc-text">9.11 生成器表达式</span></a></li></ol></li></ol>
</div>
    
</div>


<div class="search-field" id="search-field">
    <div class="search-container">
        <div class="search-input">
            <span id="esc-search"> <i class="icon-fanhui iconfont"></i></span>
            <input id="search-input"/>
            <span id="begin-search">搜索</span>
        </div>
        <div class="search-result-container" id="search-result-container">

        </div>
    </div>
</div>

        <div class="index-about-mobile">
            <i> 拂水飘绵送行色 应折柔条过千枝 </i>
        </div>
    </div>
    
    <div class="index-middle">
        <!-- Main Content -->
        


<div class="post-container">
    <div class="post-title">
        初学python2.7（九）类
    </div>

    <div class="post-meta">
        <span class="attr">发布于：<span>2019-12-20 15:01:30</span></span>
        
        <span class="attr">标签：/
        
        <a class="tag" href="/tags/#python" title="python">python</a>
        <span>/</span>
        
        
        </span>
        <span class="attr">访问：<span id="busuanzi_value_page_pv"></span>
</span>
</span>
    </div>
    <div class="post-content no-indent">
        <h1 id="类Class"><a href="#类Class" class="headerlink" title="类Class"></a>类Class</h1><blockquote>
<p>Learn from <a href="https://docs.python.org/2.7/tutorial/classes.html" target="_blank" rel="noopener">python2.7 official documentation</a></p>
<p>参考：<a href="https://blog.csdn.net/helloxiaozhe/article/details/79384554" target="_blank" rel="noopener">python中使用多继承问题和super()内置函数的使用</a></p>
</blockquote>
<p>Python的类提供了面向对象编程（Object Oriented Programming）的所有标准特性，同时也包含了Python语言的动态特性：在运行时创建，可以在创建后修改。</p>
<h2 id="9-1-名称Name和对象Object"><a href="#9-1-名称Name和对象Object" class="headerlink" title="9.1 名称Name和对象Object"></a>9.1 名称Name和对象Object</h2><p>对象具有个性（individuality），可以将多个名称（在多个作用域中）绑定到同一对象，这在其他语言中称为别名（aliasing）。在处理不可变的基本类型（immutable basic types），如<code>number</code>、<code>string</code>、<code>tuple</code>时，可以安全地忽略这一点；但在别名涉及可变对象（mutable object），如<code>list</code>、<code>dictionary</code>时，可能会产生不可预料的通常有利于程序的影响，因为别名在某些方面表现得像指针（pointers）。</p>
<h2 id="9-2-作用域Scope和命名空间Namespace"><a href="#9-2-作用域Scope和命名空间Namespace" class="headerlink" title="9.2 作用域Scope和命名空间Namespace"></a>9.2 作用域Scope和命名空间Namespace</h2><p>命名空间是一个从名字到对象的映射，大部分命名空间都由Python字典实现。</p>
<p>几个命名空间的例子：存放内置函数的集合、模块中的全局名称、函数调用的局部名称。</p>
<p>命名空间是在不同的时刻创建的，并且具有不同的生存期。</p>
<p><strong>注意</strong>：不同命名空间的名称之间没有关系。</p>
<hr>
<p>跟在点号<code>&quot;.&quot;</code>之后的名称称为属性（attribute），属性可以是只读的（read-only）或者可写的（writable）。可写的属性可以进行赋值操作<code>modname.the_answer = 42</code>（修改<code>modname</code>对象的<code>the_answer</code>属性值）及删除操作<code>del modname.the_answer</code>（从<code>modname</code>对象中移除<code>the_answer</code>属性）。</p>
<hr>
<p>作用域是一个命名空间可以直接访问的Python程序的文本区域。直接访问意味着对名称的不合理引用（unqualified reference）将试图在命名空间内查找该名称。</p>
<p>虽然作用域是静态地被确定的，但是被动态地使用的。在执行的过程中，至少有三种嵌套的作用域可以直接访问：</p>
<ul>
<li>最先搜索的（be searched first），最内层的（innermost）作用域，包含局部名称（local name）；</li>
<li>从最相近的（nearest）封闭作用域（enclosing scope）开始搜索的，任何封闭函数（enclosing function）的作用域，包含非局部名称（non-local name）和非非全局名称（non-global name）。</li>
<li>倒数第二的（next-to-last）作用域，包含当前模块的全局名称；</li>
<li>最后搜索的（searched last），最外层的（outermost）作用域，是包含内置名称的命名空间。</li>
</ul>
<p>如果一个名称被声明为全局名称（global name），则所有的引用和赋值，将直接转到包含模块全局名称的中间作用域（middle scope）；否则，在<code>innermost scope</code>外的所有变量（variable）都是只读的（read-only），尝试写入这样的变量，只会在<code>innermost scope</code>中创建一个新的局部变量，而具有相同名称的外层变量保持不变。</p>
<p>通常，局部作用域引用当前函数内的局部名称，函数外的局部作用域引用和全局作用域一样的命名空间，即模块的命名空间。类的定义将在局部作用域中加入新的命名空间。</p>
<hr>
<p>Python中，如果没有有效的<code>global</code>语句，对名称的分配总是进入最内层的作用域。分配名称不会复制数据，只会将名称绑定到对象；同样的，删除语句<code>del x</code>只是解除局部作用域引用的命名空间，与<code>x</code>之间的绑定。</p>
<p>事实上，采用新名称的所有操作都使用局部作用域，特别的，<code>import</code>语句和函数定义将模块和函数名称绑定到局部作用域。</p>
<p><code>global</code>语句可用于显示全局作用域中的特殊变量。</p>
<h2 id="9-3-初探类Class"><a href="#9-3-初探类Class" class="headerlink" title="9.3 初探类Class"></a>9.3 初探类Class</h2><p>类引入了一些新语法（syntax），三种新对象类型（object type）和一些新语义（semantic）。</p>
<h3 id="9-3-1-类定义语法Class-Definition-Syntax"><a href="#9-3-1-类定义语法Class-Definition-Syntax" class="headerlink" title="9.3.1 类定义语法Class Definition Syntax"></a>9.3.1 类定义语法Class Definition Syntax</h3><p>简单的Python类定义：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>

<h3 id="9-3-2-类对象Class-Object"><a href="#9-3-2-类对象Class-Object" class="headerlink" title="9.3.2 类对象Class Object"></a>9.3.2 类对象Class Object</h3><p>当程序从结尾处正常离开类定义时，将会创建一个类对象，它作为类定义中创建的命名空间的封装器（wrapper），并绑定到类定义所给出的类名称上，如上文中的<code>ClassName</code>。</p>
<p>类对象支持两种操作：属性引用（attribute reference）和实例化（instantiation）。</p>
<h4 id="9-3-2-1-属性引用"><a href="#9-3-2-1-属性引用" class="headerlink" title="9.3.2.1 属性引用"></a>9.3.2.1 属性引用</h4><p>类属性引用使用Python中属性引用的标准语法<code>obj.name</code>。有效的属性名称（attribute name）包括类对象被创建时存在于类命名空间中的所有名称，包括数据属性（data attribute）和方法（method）。如果类定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">"""A simple example class"""</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br></pre></td></tr></table></figure>

<p>那么有效的属性引用包括：<code>MyClass.i</code>和<code>MyClass.f</code>，其分别返回一个整数和一个函数对象。</p>
<p>类属性也可以被赋值（assignment），因此可以通过赋值操作来更改<code>MyClass.i</code>的值。</p>
<p><code>__doc()__</code>也是一个有效的属性，其返回所属类的文档字符串，如上文中的<code>&quot;A simple example class&quot;</code>。</p>
<h4 id="9-3-2-2-实例化"><a href="#9-3-2-2-实例化" class="headerlink" title="9.3.2.2 实例化"></a>9.3.2.2 实例化</h4><p>类的实例化使用Python中函数表示法，可把类对象视为，返回该类的一个新实例的不带参数的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = MyClass()</span><br></pre></td></tr></table></figure>

<p>实例化操作会创建一个空对象，许多类喜欢创建带有特定初始状态的自定义实例，为此，类定义中可以包含一个名为<code>__init()__</code>的特殊方法，当类定义了<code>__init()__</code>方法时，实例化操作会自动为新创建的类实例调用<code>__init()__</code>方法。</p>
<p>除了第一个参数<code>self</code>是必须的；<code>__init()__</code>方法还可以有额外的参数，这种情况下，实例化时提供的参数将被传递给<code>__init()__</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span>:</span></span><br><span class="line">    <span class="string">"""A simple example class"""</span></span><br><span class="line">    i = <span class="number">12345</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, realpart, imagpart)</span>:</span></span><br><span class="line">        self.r = realpart</span><br><span class="line">        self.i = imagpart</span><br><span class="line"></span><br><span class="line">x = MyClass(<span class="number">3.0</span>, <span class="number">-4.5</span>)</span><br><span class="line"><span class="keyword">print</span> x.r, x.i</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">3.0</span> <span class="number">-4.5</span></span><br></pre></td></tr></table></figure>

<h3 id="9-3-3-实例对象"><a href="#9-3-3-实例对象" class="headerlink" title="9.3.3 实例对象"></a>9.3.3 实例对象</h3><p>实例对象可以接收的唯一操作为属性引用，有效的属性名称包括数据属性和方法。</p>
<hr>
<p>数据属性不需要声明，和局部变量一样，其在第一次被赋值时产生：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x.counter = <span class="number">1</span></span><br><span class="line"><span class="keyword">while</span> x.counter &lt; <span class="number">10</span>:</span><br><span class="line">    x.counter = x.counter * <span class="number">2</span></span><br><span class="line"><span class="keyword">print</span> x.counter</span><br><span class="line"><span class="keyword">del</span> x.counter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">16</span></span><br></pre></td></tr></table></figure>

<p><code>x</code>为上文中<code>MyClass</code>的实例，代码段打印数值<code>16</code>而不会保留任何追踪信息（新产生的数据属性<code>counter</code>在结尾被<code>del</code>语句清除）。</p>
<hr>
<p>实例对象引用的方法是属于对象的函数，有效的方法名称依赖于实例对象所属的类，类定义中所有的函数对象属性，都是其实例的相应方法。</p>
<p><code>x.f</code>即为有效的方法引用，因为<code>MyClass.f</code>是一个函数，但<code>x.f</code>和<code>MyClass.f</code>并不相同，<code>x.f</code>是方法对象（method object），<code>MyClass.f</code>是函数对象（function object）。</p>
<h3 id="9-3-4-方法对象Method-Object"><a href="#9-3-4-方法对象Method-Object" class="headerlink" title="9.3.4 方法对象Method Object"></a>9.3.4 方法对象Method Object</h3><p>通常，方法在绑定后立即被调用，在<code>MyClass</code>的实例中，这将返回字符串<code>&#39;hello world&#39;</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.f()</span><br></pre></td></tr></table></figure>

<p>立即调用一个方法并不是必须的，<code>x.f</code>是一个方法对象，其可以被保存起来，以后再调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xf = x.f</span><br><span class="line"><span class="keyword">print</span> xf()</span><br></pre></td></tr></table></figure>

<p>方法的特殊之处在于，调用时，对象作为函数的第一个参数<code>self</code>传递给方法，<code>x.f()</code>与<code>MyClass.f(x)</code>完全等价。</p>
<p>当一个实例的非数据属性被引用时，将搜索实例所属的类，如果名称表示一个属于函数对象的有效类属性，Python将合并实例对象和函数对象到一个抽象对象中，这个抽象对象就是方法对象。调用方法对象时，如果附带参数列表，将会基于实例对象和参数列表来构建一个新的参数列表，并使用新的参数列表来调用相应的函数对象。</p>
<h3 id="9-3-5-类和实例变量Instance-Variable"><a href="#9-3-5-类和实例变量Instance-Variable" class="headerlink" title="9.3.5 类和实例变量Instance Variable"></a>9.3.5 类和实例变量Instance Variable</h3><p>一般的，实例变量用于每个实例的唯一数据，类变量用于类的所有实例共享的属性。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    kind = <span class="string">'canine'</span>         <span class="comment"># 类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name    <span class="comment"># 实例变量</span></span><br></pre></td></tr></table></figure>

<p>注意：将可变对象，如列表、字典，作为类变量时，所有类的实例将共享一个单独的变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    tricks = []             <span class="comment"># 错误使用类变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_trick</span><span class="params">(self, trick)</span>:</span></span><br><span class="line">        self.tricks.append(trick)</span><br><span class="line">        </span><br><span class="line">d = Dog(<span class="string">'Fido'</span>)</span><br><span class="line">e = Dog(<span class="string">'Buddy'</span>)</span><br><span class="line">d.add_trick(<span class="string">'roll over'</span>)</span><br><span class="line">e.add_trick(<span class="string">'play dead'</span>)</span><br><span class="line">d.tricks                <span class="comment"># 所有Dog的实例共享同一个tricks</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'roll over'</span>, <span class="string">'play dead'</span>]</span><br></pre></td></tr></table></figure>

<p>正确的类设计应该使用实例变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.tricks = []    <span class="comment"># 为每个Dog的实例创建新的列表变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_trick</span><span class="params">(self, trick)</span>:</span></span><br><span class="line">        self.tricks.append(trick)</span><br></pre></td></tr></table></figure>

<h2 id="9-4-补充说明"><a href="#9-4-补充说明" class="headerlink" title="9.4 补充说明"></a>9.4 补充说明</h2><p>数据属性会覆盖掉具有相同名称的方法属性。</p>
<hr>
<p>数据属性可以被方法以及一个对象的普通用户（“客户端”）所引用。换句话说，类不能用于实现纯抽象数据类型。 实际上，在 Python 中没有任何东西能强制隐藏数据 — 它是完全基于约定的。 </p>
<hr>
<p>在方法内部引用数据属性或其他方法并没有简便方式。 </p>
<p>约定的，方法的第一个参数常常被命名为 <code>self</code>，这一名称在 Python 中没有特殊含义。</p>
<hr>
<p>任何一个作为类属性的函数都为该类的实例定义了一个相应方法，函数定义可以在类定义之外，将函数对象赋值给一个局部变量是可行的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在类定义外定义方法函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f1</span><span class="params">(self, x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> min(x, x+y)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    f = f1</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'hello world'</span></span><br><span class="line"></span><br><span class="line">    h = g</span><br></pre></td></tr></table></figure>

<p><code>f</code>，<code>g</code>和<code>h</code>都是<code>C</code>类引用函数对象的属性，都是<code>C</code>实例的方法。</p>
<hr>
<p>方法可以通过使用<code>self</code>参数调用其他方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bag</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.data = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.data.append(x)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addtwice</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        self.add(x)</span><br><span class="line">        self.add(x)</span><br></pre></td></tr></table></figure>

<hr>
<p>可以通过<code>object.__class__</code>来获取对象所属的类。</p>
<h2 id="9-5-继承Inheritance"><a href="#9-5-继承Inheritance" class="headerlink" title="9.5 继承Inheritance"></a>9.5 继承Inheritance</h2><p>派生类定义的基本语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(BaseClassName)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>

<p>名称<code>BaseClassName</code>必须定义于包含派生类定义的作用域中，当基类定义在引用的模块中时，可以通过表达式表示基类位置：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(modname.BaseClassName)</span>:</span></span><br></pre></td></tr></table></figure>

<p>派生类定义的执行过程中，当构造类对象时，基类会被记住，此信息将被用来解析属性引用：如果请求的属性在类中找不到，搜索将转往基类中进行查找；如果基类本身也派生自其他某个类，则此规则将被递归地应用。</p>
<hr>
<p>派生类可能会重载其基类的方法。</p>
<p>对 C++ 程序员的提示：Python 中所有的方法实际上都是 <code>virtual</code> 方法。（暂时无法理解？）</p>
<p>在派生类中的重载方法，实际上可能想要<strong>扩展</strong>而非替换同名的基类方法。</p>
<p>使用<code>BaseClassName.methodname(self, arguments)</code>可以简单地直接调用基类方法，此方式仅当基类名称在全局作用域中存在时可用。</p>
<hr>
<p>Python中关于继承机制的内置函数：</p>
<ul>
<li><code>isinstance(obj, int)</code>：用于检查一个<code>obj</code>实例的类型，仅当<code>obj.__class__</code>为<code>int</code>或某个派生自<code>int</code>的类时为<code>True</code>。</li>
<li><code>issubclass(class, classinfo)</code>：用于检查类的继承，当<code>class</code>为<code>classinfo</code>的子类时为<code>True</code>；当<code>class</code>不是<code>classinfo</code>的子类，它们只有<code>basestring()</code>一个共同的祖先时为<code>False</code>。</li>
</ul>
<h3 id="9-5-1-多重继承Multiple-Inheritance"><a href="#9-5-1-多重继承Multiple-Inheritance" class="headerlink" title="9.5.1 多重继承Multiple Inheritance"></a>9.5.1 多重继承Multiple Inheritance</h3><p>Python多重继承的派生类定义的基本语法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DerivedClassName</span><span class="params">(Base1, Base2, Base3)</span>:</span></span><br><span class="line">    &lt;statement<span class="number">-1</span>&gt;</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    .</span><br><span class="line">    &lt;statement-N&gt;</span><br></pre></td></tr></table></figure>

<p><code>MRO</code>即方法解析顺序(method resolution order)，用于判断子类调用的属性来自于哪个父类。在<code>Python2.3</code>之前，<code>MRO</code>是基于深度优先算法的，自<code>Python2.3</code>开始使用<code>C3</code>算法，定义类时需要继承<code>object</code>，这样的类称为新式类，否则为旧式类。</p>
<h2 id="9-6-私有变量Private-Variables和类局部引用Class-local-References"><a href="#9-6-私有变量Private-Variables和类局部引用Class-local-References" class="headerlink" title="9.6 私有变量Private Variables和类局部引用Class-local References"></a>9.6 私有变量Private Variables和类局部引用Class-local References</h2><p>Python中不存在只能从对象内部访问的私有实例变量，约定的，以下划线开头的名称，如<code>_span</code>被视为<code>API</code>非公开的部分，无论其为函数、方法还是数据成员。</p>
<h3 id="9-6-1-名称改写name-mangling"><a href="#9-6-1-名称改写name-mangling" class="headerlink" title="9.6.1 名称改写name mangling"></a>9.6.1 名称改写name mangling</h3><p>为了避免，类似私有成员的名称与子类所定义的名称相冲突，这类情况的出现，Python提供名称改写（name mangling）机制，由至少两个前缀下划线，至多一个后缀下划线构成的标识符文本，如<code>__spam</code>，将被替换为<code>_classname__spam</code>，其中<code>classname</code>为去除了前缀下划线的当前类名称，这种改写不考虑标识符的位置，只要出现在类定义内部就会进行。</p>
<p>名称改写有助于让子类重载方法而不破坏类内方法调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Mapping</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        self.items_list = []</span><br><span class="line">        self.__update(iterable)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, iterable)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> iterable:</span><br><span class="line">            self.items_list.append(item)</span><br><span class="line"></span><br><span class="line">    __update = update   <span class="comment"># 原始update()方法的私有拷贝</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MappingSubclass</span><span class="params">(Mapping)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span><span class="params">(self, keys, values)</span>:</span></span><br><span class="line">        <span class="comment"># 提供update()新的重载</span></span><br><span class="line">        <span class="comment"># 而不会改变基类Mapping的__init__()</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> zip(keys, values):</span><br><span class="line">            self.items_list.append(item)</span><br></pre></td></tr></table></figure>

<p>上面的示例即使在 <code>MappingSubclass</code> 引入了一个<code>__update</code>标识符的情况下也不会出错，因为它会在<code>Mapping</code>类中被替换为<code>_Mapping__update</code>而在<code>MappingSubclass</code>类中被替换为<code>_MappingSubclass__update</code>。</p>
<h2 id="9-7-杂项说明"><a href="#9-7-杂项说明" class="headerlink" title="9.7 杂项说明"></a>9.7 杂项说明</h2><p>有时会需要使用类似于<code>C</code>的<code>&quot;struct&quot;</code>这样的数据类型，将一些命名数据项捆绑在一起。这种情况适合定义一个空类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">john = Employee()  <span class="comment"># 创建一个空的Employee员工记录</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 填充记录的字段</span></span><br><span class="line">john.name = <span class="string">'John Doe'</span></span><br><span class="line">john.dept = <span class="string">'computer lab'</span></span><br><span class="line">john.salary = <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<hr>
<p>实例方法对象也具有属性。</p>
<p>文档原文：Instance method objects have attributes, too: <code>m.im_self</code> is the instance object with the method <code>m()</code>, and <code>m.im_func</code> is the function object corresponding to the method.</p>
<h2 id="9-8-异常Exception是类"><a href="#9-8-异常Exception是类" class="headerlink" title="9.8 异常Exception是类"></a>9.8 异常Exception是类</h2><p>如果<code>except</code>子句中的类是异常的基类，那么该子句与异常兼容，此兼容不可逆：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(B)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(C)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> [B, C, D]:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">raise</span> c()</span><br><span class="line">    <span class="keyword">except</span> D:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"D"</span></span><br><span class="line">    <span class="keyword">except</span> C:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"C"</span></span><br><span class="line">    <span class="keyword">except</span> B:</span><br><span class="line">        <span class="keyword">print</span> <span class="string">"B"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B C D</span><br></pre></td></tr></table></figure>

<p>如果将<code>except</code>子句顺序颠倒，将打印<code>B B B</code>。</p>
<h2 id="9-9-迭代器Iterator"><a href="#9-9-迭代器Iterator" class="headerlink" title="9.9 迭代器Iterator"></a>9.9 迭代器Iterator</h2><p><code>Python</code>中，大多数的容器对象都可以使用<code>for</code>语句进行迭代：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]:</span><br><span class="line">    <span class="keyword">print</span> element</span><br><span class="line"><span class="keyword">for</span> element <span class="keyword">in</span> (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>):</span><br><span class="line">    <span class="keyword">print</span> element</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> &#123;<span class="string">'one'</span>:<span class="number">1</span>, <span class="string">'two'</span>:<span class="number">2</span>&#125;:</span><br><span class="line">    <span class="keyword">print</span> key</span><br><span class="line"><span class="keyword">for</span> char <span class="keyword">in</span> <span class="string">"123"</span>:</span><br><span class="line">    <span class="keyword">print</span> char</span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> open(<span class="string">"myfile.txt"</span>):</span><br><span class="line">    <span class="keyword">print</span> line</span><br></pre></td></tr></table></figure>

<p>实际上，<code>for</code>语句在开始时，调用了容器对象的<code>iter()</code>函数，这个函数返回一个迭代器（iterator）对象。迭代器对象定义了<code>next()</code>方法，该方法一次去访问容易中的一个元素，并返回元素值，当没有更多的元素时，<code>next()</code>方法抛出<code>StopIteration</code>异常，来提示<code>for</code>语句终止循环：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>s = <span class="string">'abc'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it = iter(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it</span><br><span class="line">&lt;iterator object at <span class="number">0x00A1DB50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it.next()</span><br><span class="line"><span class="string">'a'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it.next()</span><br><span class="line"><span class="string">'b'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it.next()</span><br><span class="line"><span class="string">'c'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>it.next()</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    it.next()</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure>

<p>将迭代器添加到类中，只需要在类中定义<code>__iter()__</code>方法，该方法返回带有<code>next()</code>方法的对象；如果同时在类中定义了<code>next()</code>方法，则<code>__iter()__</code>可以返回<code>self</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Reverse</span>:</span></span><br><span class="line">    <span class="string">"""实现用于逆向循环序列data的迭代器"""</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, data)</span>:</span></span><br><span class="line">        self.data = data</span><br><span class="line">        self.index = len(data)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">next</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> self.index == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.index = self.index - <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.data[self.index]</span><br></pre></td></tr></table></figure>

<p>使用上文实现的迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>rev = Reverse(<span class="string">'spam'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>iter(rev)</span><br><span class="line">&lt;__main__.Reverse object at <span class="number">0x00A1DB50</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> rev:</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> char</span><br><span class="line">...</span><br><span class="line">m</span><br><span class="line">a</span><br><span class="line">p</span><br><span class="line">s</span><br></pre></td></tr></table></figure>

<h2 id="9-10-生成器Generator"><a href="#9-10-生成器Generator" class="headerlink" title="9.10 生成器Generator"></a>9.10 生成器Generator</h2><p>生成器是用于创建迭代器的工具，它可以自动为创建的迭代器添加<code>__iter()__</code>和<code>next()</code>方法。</p>
<p>生成器写法类似标准函数，返回数据时使用<code>yield</code>语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverse</span><span class="params">(data)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(len(data)<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>):</span><br><span class="line">        <span class="keyword">yield</span> data[index]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> char <span class="keyword">in</span> reverse(<span class="string">'golf'</span>):</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">print</span> char</span><br><span class="line">...</span><br><span class="line">f</span><br><span class="line">l</span><br><span class="line">o</span><br><span class="line">g</span><br></pre></td></tr></table></figure>

<p>生成器的局部变量和执行状态会在每次调用之间自动保存，每次对生成器调用<code>next()</code>时，它会从上次离开位置恢复执行。</p>
<p>除了会自动创建方法和保存程序状态，当生成器终结时，它们还会自动引发<code>StopIteration</code>。</p>
<h2 id="9-11-生成器表达式"><a href="#9-11-生成器表达式" class="headerlink" title="9.11 生成器表达式"></a>9.11 生成器表达式</h2><p>某些简单的生成器可以写成简洁的表达式代码，所用语法类似列表推导式，但外层为圆括号而非方括号。</p>
<p>这种表达式被设计用于，生成器将立即被外层函数所使用的情况。</p>
<p>生成器表达式相比完整的生成器更紧凑但较不灵活，相比等效的列表推导式则更为节省内存。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(i*i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))                 <span class="comment"># sum of squares</span></span><br><span class="line"><span class="number">285</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>xvec = [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>yvec = [<span class="number">7</span>, <span class="number">5</span>, <span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum(x*y <span class="keyword">for</span> x,y <span class="keyword">in</span> zip(xvec, yvec))         <span class="comment"># dot product(点积)</span></span><br><span class="line"><span class="number">260</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> math <span class="keyword">import</span> pi, sin</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sine_table = dict((x, sin(x*pi/<span class="number">180</span>)) <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">91</span>))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>unique_words = set(word  <span class="keyword">for</span> line <span class="keyword">in</span> page  <span class="keyword">for</span> word <span class="keyword">in</span> line.split())</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>valedictorian = max((student.gpa, student.name) <span class="keyword">for</span> student <span class="keyword">in</span> graduates)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>data = <span class="string">'golf'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(data[i] <span class="keyword">for</span> i <span class="keyword">in</span> range(len(data)<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">-1</span>))</span><br><span class="line">[<span class="string">'f'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>, <span class="string">'g'</span>]</span><br></pre></td></tr></table></figure>
        
        <br />
        <div id="comment-container">
        </div>
        <div id="disqus_thread"></div>

        <div id="lv-container">
        </div>

    </div>
</div>

    </div>
</div>


<footer class="footer">
    <ul class="list-inline text-center">
        
        

        

        

        

        

    </ul>
    
    <p>
        <span>/</span>
        
        <span><a href="">FlowerMushroom&#39;s Page</a></span>
        <span>/</span>
        
        <span><a href="">この世界私は大好きです</a></span>
        <span>/</span>
        
    </p>
    

    <p>
        /&nbsp;Bilibili :&nbsp;&nbsp;<a href="https://github.com/FlowerMushroom/">花蘑菇爱吃草莓</a>&nbsp;&nbsp;/&nbsp;GitHub :&nbsp;&nbsp;<a href="https://github.com/FlowerMushroom/">FlowerMushroom</a>&nbsp;&nbsp;/
    </p>
</footer>




</body>

<script>
    // We expose some of the variables needed by the front end
    window.hexo_search_path = "search.json"
    window.hexo_root = "/"
    window.isPost = true
</script>
<script src="https://cdn.bootcss.com/jquery/3.3.1/jquery.min.js"></script>
<script src="/js/index.js"></script>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>




</html>
