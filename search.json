[{"title":"PHP学习笔记（一）","url":"/2019/07/27/PHP学习笔记（一）/","content":"\n## 一、PHP语法初步\n\nPHP是一种运行在服务端的脚本语言，可以嵌入到HTML中。\n\n### （1）PHP代码标记\n\n在PHP历史发展中，可以使用多种标记来区分PHP脚本。\n\n------\n\n【基本弃用】\n\nASP标记：\n\n```\n<% php代码 %>\n```\n\n短标记：\n\n```\n<? php代码 ?>\n```\n\n------\n\n脚本标记：\n\n```php+HTML\n<script language=\"php\"> php代码 </script>\n\n<html>\n    <body>\n        <b>\n        \t<script language=\"php\">\n            \t//脚本标记\n                echo 'hello world';\n            </script>\n        </b>\n    </body>\n</html>\n```\n\n【最常用】标准标记：\n\n```\n<?php php代码 ?>\n\n<html>\n    <body>\n        <b>\n        \t<?php\n            \t//脚本标记\n                echo 'hello world;\n            ?>\n        </b>\n    </body>\n</html>\n```\n\n### （2）PHP注释\n\n**1.行注释**\n\n一次注释一行\n\n```php\n//注释内容\n#注释内容\n```\n\n**2.块注释**\n\n一次注释多行\n\n```php\n/*\n注释内容\n*/\n```\n\n### （3）PHP语句分隔符\n\n语句分隔符：在PHP中，代码以行为单位，系统通过分号 ; 来判断行的结束。\n\n```php\n$a = 5;\necho 'hello world';\n```\n\n**特殊说明：**\n\n1. php中标记结束符 ?> 有自带语句结束符的效果，最后一行php代码可以没有语句结束符 ; 。【不建议使用】\n2. php中很多代码的书写并不是嵌入到HTML中，而是单独存在，通常书写习惯中不建议使用 ?> ，php会自动从开始到最后全部认为是php代码，从而解析。\n\n## 二、变量\n\nphp是一种动态网站开发的脚本语言，动态语言特点是交互性，会有数据的传递，而php作为\"中间人\"，需要进行数据的传递，传递的前提就是php自己能存储（临时）数据。\n\n### （1）变量的使用\n\nPHP中的所有变量都必须使用 $ 符号。\n\n**1.定义**：在系统中增加对应的变量名字。（内存）\n\n```php\n<?php\n    $var1;\t\t//定义变量\n```\n\n**2.赋值**：可以将数据赋值给变量名。\n\n```php\n<?php\n    $var2 = 1;\t//定义同时赋值\n\n```\n\n**3.可以通过变量名访问存储的数据**\n\n```php\n<?php\n    $var2 = 1;\n    echo $var2;\t//通过var2变量名字找到存储的内容1，然后输出\n\t\n\t$var2 = 2;\t//修改变量\n\techo '<hr/>', $var2;\n\n```\n\n**4.可以将变量从内存中删除**\n\n```php\n<?php\n    //删除变量，使用unset(变量名)\n    $var2 = 1;\n\tunset($var2);\n\n```\n\n### （2）变量命名规则\n\n1. 在PHP中变量名字必须以 \"$\" 符号开始。\n2. 名字由字母，数字和下划线构成，但不能以数字开头。\n3. PHP本身中允许中文变量。【不推荐】\n\n### （3）预定义变量\n\n提前定义的变量，系统定义的变量，存储许多需要用到的数据。\n\n这些预定义变量都是数组。\n\n```php\n$_GET;\t\t\t//获取所有表单以GET方式提交的数据\n$_POST;\t\t\t//POST提交的数据都会保存在此\n$_REQUEST;\t\t//GET和POST提交的数据都会保存在此\n$GLOBALS;\t\t//PHP中所有的全局变量\n$_SERVER;\t\t//服务器信息\n$_SESSION;\t\t//session会话数据\n$_COOKIE;\t\t//cookie会话数据\n$_ENV;\t\t\t//环境信息\n$_FILES;\t\t//用户上传的文件信息\n\n```\n\n### （4）可变变量\n\n如果一个变量保存的值，刚好的是另外一个变量的名字，那么可以直接通过访问一个变量得到另外一个变量的值。\n\n语法：在变量前面再多加一个 $ 符号。\n\n```php\n<?php\n\t//定义两个变量\n\t$a = 'b';\n\t$b = 'bb';\n\t\n\techo $$a;\t\t//输出'bb'\n\n```\n\n过程：\n\n1.找到 $a ，解析结果：'b'\n\n2.将前面的 $ 与结果 'b' 绑定，得到：$b\n\n3.解析 $b\n\n### （5）变量传值\n\n将一个变量赋值给另外一个变量。\n\n**1.值传递**\n\n将变量保存的值复制一份，然后将新的值给另外一个变量保存。【两个变量没有关系】\n\n```php\n<?php\n    $a = 1;\n\t$b = $a;\t\t//值传递\n\n\t$b = 2;\n\techo $a,$b;\t\t//1,2\n\n```\n\n**2.引用传递**\n\n将变量保存的值所在的内存地址，传递给另外一个变量，两个变量指向同一块内存空间。【两个变量是同一个值】\n\n```php\n<?php\n    $a = 1;\n\t$b = &$a;\t\t//引用传递\n\n\t$b = 2;\n\techo $a,$b;\t\t//2,2\n\n```\n\n\n\n```\n在内存中，通常有以下几个分区：\n栈区：程序可以操作的内存部分，不存储数据，运行程序代码，小但快速。\n代码段：存储程序的内存部分，存储但不执行。\n数据段：存储普通数据，包括全局区和静态区。\n堆区：存储复杂数据的部分，大但效率低。\n\n```\n\n## 三、常量\n\n### （1）基本概念\n\n常量：const/constant，是一种在程序运行当中，不可改变的量（数据）。\n\n常量一旦定义，通常数据不可改变（用户级别）。\n\n### （2）常量定义形式\n\n**1.使用定义常量的函数：define('常量名', 常量值)**\n\n```php\n<?php\n    define('PI', 3.14);\n\n```\n\ndefine()函数定义的常量默认不区分大小写，可以改变函数参数以区分大小写。\n\n**2.const 常量名 = 值; 【此方法php5.3之后出现】**\n\n```php\n<?php\n    const PI = 3.14;\n\n```\n\n**3. define() 和 const 两种方式定义的常量，有访问权限上的区别。**\n\n### （3）常量命名规则\n\n1. 常量不需要使用特殊符号 \"$\"。\n2. 常量的名字由字母、数字和下划线组成，不能以数字开头。\n3. 常量名字通常以大写字母为主（与变量区别）。\n4. 常量命名规则比变量松散，可以使用一些特殊字符。【这种常量只能用define()定义】拥有特殊字符的常量需要用函数 constant('常量名')  来访问。\n\n### （4）系统常量\n\n系统帮主用户定义的常量，用户可以直接使用。\n\n```\nPHP_VERSION：PHP版本号\nPHP_INT_SIZE：整型所占用的字节数\nPHP_INT_MAX：整型能表示的最大值\n\n```\n\n**系统魔术常量**：双下划线+常量名+双下划线，魔术常量的值会跟随环境变化，但用户不能改变。\n\n```\n__DIR__\t\t\t:当前被执行的脚本所在电脑的绝对路径\n__FILE__\t\t:当前被执行的脚本所在电脑的绝对路径，包括自己文件的名字\n__LINE__\t\t:当前所属的行数\n__NAMESPACE__\t:当前所属的命名空间\n__CLASS__\t\t:当前所属的类\n__METHOD__\t\t:当前所属的方法\n\n```\n\n\n\n## 四、数据类型\n\n因为php是一种弱类型语言，php变量本身没有数据类型，数据类型data type在php中指的是存储的数据本身的类型。\n\n### （1）php中的八种数据类型\n\n**三大类：**\n\n#### 1.简单（基本）数据类型：4小类\n\n**整型**：int/integer，4字节，表示整数类型。\n\n**浮点型**：float/double，8字节，表示小数或整型存不下的整数。\n\n**字符串型**：string，系统根据实际长度分配空间，表示字符串（引号）。\n\n**布尔类型**：bool/boolean，表示布尔类型，只有两个值：true和false。\n\n#### 2.复合数据类型：2小类\n\n**对象类型**：object，存放对象（OO）。\n\n**数组类型**：array，存储多个数据（一次性）。\n\n#### 3.特殊数据类型：2小类\n\n**资源类型**：resouce，存放资源数据（php外部数据，如数据库、文件）。\n\n**空类型**：NULL，只有一个值NULL，不能运算。\n\n### （2）类型转换\n\n在很多情况下，需要将外部数据（当前php取得的数据）转换成目标数据类型。\n\n**1.自动转换**：系统根据需求自己判定，自己转换。使用多，效率偏低。\n\n**2.强制转换**：人为根据需要的目标类型转换。\n\n```php\n(目标类型)$变量\n\n```\n\n在转换过程中使用较多的：转布尔类型（判断）和转数值类型（算术运算）。\n\n其他类型转bool：true和false。\n\n其他类型转数值：\n\n```php\n/*\n1.bool转数值：true为1，false为0。\n2.字符串转数值：\n\t2.1 以字母开头的字符串，永远为0。\n\t2.2 以数字开头的字符串，取碰到字符串为止的数字，不会同时包含两个小数点。\n*/\n\n<?php\n    //创建数据\n    $a = 'abc1.1.1';\n\t$b = '1.1.1abc';\n\t//自动转换 1.1\n\techo $a + $b;\n\t//强制转换 0 1.1\n\techo '<br/>',(float)$a,(float)$b;\n\n```\n\n### （3）类型判断\n\n#### 1.is_数据类型($变量名)\n\n通过一组类型判断函数，来判断变量，最终返回这个变量所保存数据的数据类型与函数类型是否相同，相同返回 true ，不同返回 false 。\n\n是一组以 is_ 开头，后面跟类型名字的函数：\n\n```php\nis_数据类型($变量名)\n\n```\n\nBool类型不能用echo来查看，可以使用 **var_dump(变量1, 变量2, ...)** 来查看。\n\n```php\n<?php\n    //创建数据\n    $a = 'abc1.1.1';\n\t$b = '1.1.1abc';\n\t\n\tvar_dump(is_int($a));\t\t//bool(false)\n\tvar_dump(is_string($a));\t//bool(true)\n\n```\n\n#### 2.gettype($变量名)\n\n用来获取数据（变量）的类型。\n\n获取类型，得到的是该类型对应的字符串。\n\n#### 3.bool settype($变量名, 类型)\n\n用来设定数据（变量）的类型。\n\n设定数据类型，与强制转换不同， settype() 会直接改变存储的数据本身。\n\n返回值bool为设定类型是否成功。\n\n### （4）整数、浮点、布尔\n\n#### 1.整数类型\n\n保存整数数值（范围限制），4Bytes存储数据，最大32bits。\n\nphp中整型默认为**有符号**类型。\n\n定义方式：\n\n```php\n<?php\n\t#十进制定义\n\t$a1 = 120;\n\t\n\t#二进制定义 0b+二进制数值\n\t$a2 = 0b110;\n\t\n\t#八进制定义 0+八进制数值\n\t$a8 = 0120;\n\t\n\t#十六进制定义 0x+十六进制数值\n\t$a16 = 0x120;\n\n```\n\n#### 2.浮点类型\n\n浮点型：小数类型以及超过整型存储范围的整数（不保证精度）。\n\n精度范围：大概在15个有效数字左右。\n\n定义方式：\n\n```php\n<?php\n\t$f1 = 1.23;\n\t$f2 = 1.23e10;\t\t\t//科学计数法\n\t$f3 = PHP_INT_MAX + 1\t//整型超过自身存储大小后会变为浮点型存储\n\n```\n\n**浮点数保存的数据不够精确**，尽量不用浮点数进行精确判断。\n\n```php\n<?php\n\t$f4 = 0.7;\n\t$f5 = 2.1;\n\t$f6 = $f5 / 3;\n\tvar_dump($f4 == $f6);\t//bool(false)\n\n```\n\n#### 3.布尔类型\n\n两个值：true 和 false。\n\n通常用于判断比较。\n\n empty()：判断数据的值是否为\"空\"（不是NULL），如果为\"空\"返回 true 。\n\nisset()：判断数据的值是否存在，存在返回 true 。\n\n## 五、运算符\n\n**operator**\n\n### （1）赋值运算符\n\n赋值运算：\"=\"，将右边的结果（可以是变量、数据、常量、其他运算出来的结果）保存到内存的某一个位置，将这个位置的内存地址赋值给左侧的变量（常量）。\n\n### （2）算术运算符\n\n算术运算：基本的算术操作。\n\n```\n+：加\n-：减\n*：乘\n/：除\n%：取余（模运算）\n\n```\n\n### （3）比较运算符\n\n比较运算：比较两个数据的大小或是否相同。\n\n```\n>：大于\n>=：大于等于\n<：小于\n<=：小于等于\n==：等于（大小相同）\n!=：不等于（大小不同）\n===：全等于（大小以及数据类型完全相同）\n!==：不全等于（大小或类型不同）\n\n```\n\n等于和全等例子：\n\n```php\n<?php\n\t$a = '123';\n\t$b = 123;\n\t\n\tvar_dump($a == $b);\t\t//bool(true)\n\tVar_dump($a === $b);\t//bool(false)\n\n```\n\n### （4）逻辑运算符\n\n逻辑运算：针对不同的结果进行匹配。\n\n```\n&&：逻辑与，两边条件同时成立返回 true 。\n||：逻辑或，两边条件只要有一个成立返回 true 。\n!：逻辑非，对已有条件取反。\n\n```\n\n&& 和 || 又称为**短路运算**，如果第一个表达式结果已经可以得出返回值，那么就不会运行逻辑运算符后面的表达式。\n\n### （5）连接运算符\n\n连接运算：php中将多个字符串拼接的一种符号。\n\n```\n.：将两个字符串连接到一起\n.=：符合运算，将左面的内容与右边的内容连接起来，然后重新赋值给左边变量。\n\n```\n\n### （6）错误抑制符\n\nphp中有一些错误可以提前预知，但可能无法避免，这时可以使用错误抑制符处理。\n\n```\n@：在可能出错的表达式前面使用@符号\n\n```\n\n例子：\n\n```\n<?php\n\t$a = 10;\n\t$b = 0;\n\t@($a % $b);\t\t//不会报错\n\n```\n\n错误抑制符通常在生产环境（上线）用到，在开发时不会使用。\n\n### （7）三目运算符\n\n三目运算符：有三个表达式参与的运算，是简单的分支结构的缩写。\n\n```\n表达式1 ? 表达式2 : 表达式3;\n\n```\n\n如果表达式1成立，那么执行表达式2，否则执行表达式3。\n\n### （8）自操作运算符\n\n自操作：自己操作自己的运算符。\n\n```\n++：在原值上加1\n--：在原值上-1\n\n```\n\n### （9）位运算符\n\n位运算：取出计算机中最小的单位（bit）进行运算。\n\n```\n$：按位与，两个位都为1，结果位1，否则为0\n|：按位或，两个有一个为1，结果为1\n~：按位非，如果为1，则变成0，否则反之\n^：按位异或，两个相同则为0，不同则为1\n<<：按位左移，整个二进制数向左移动一定位数，右边补0，相当于乘以2操作\n>>：按位右移，整个二进制数向右移动一定位数，左边补符号位对应值（正数补0，负数补1），相当于除以2操作\n\n```\n\n注意：\n\n1.系统进行任何位运算时，使用的都是**补码**\n\n2.运算结束后都必须转换成**原码**才是最终要显示的数据\n\n## 六、流程控制\n\n流程控制：代码执行的方向\n\n### （1）控制分类\n\n**顺序结构**：代码从上向下顺序执行，代码执行的最基本结构\n\n**分支结构**：给定一个条件，同时有多种可执行代码（块），然后会根据条件执行某一段代码\n\n**循环结构**：在某个条件控制范围内，指定的代码（块）可以重复执行\n\n### （2）分支结构\n\n#### 1.if分支\n\n```php\n//最简if\nif(条件表达式)\n{\n    //满足条件所要执行的代码\n}\n\n//基础if\nif(条件表达式)\n{\n    //满足条件所要执行的代码\n}else{\n\t//不满足条件所要执行的代码   \n}\n\n//复杂if\nif(条件表达式1)\n{\n\t//满足条件1所要执行的代码\n}elseif(条件表达式2){\n    //满足条件2所要执行的代码\n}elseif(条件表达式...){\t//可以使用多个elseif来进行条件筛选\n\n}else{\n    //所有条件全部不满足所要执行的代码\n}\n\n```\n\n#### 2.swich分支\n\n```php\nswitch(条件表达式){\n\t//所有条件判断：逐个执行\n\tcase 值1:\t//当前表达式的结果与值1相等\n\t\t//要执行的代码段\n\t\tbreak;\t//中断swich\n\tcase 值2:\t//当前表达式的结果与值1相等\n\t\t//要执行的代码段\n\t\tbreak;\t//中断swich\n        \n    //...设置任意数量匹配值    \n        \n    default:\n        //匹配失败的代码\n}\n\n```\n\n### （3）循环结构\n\n#### 1.for循环\n\n```php\n/*\n\t条件表达式1：定义初始化条件\n\t条件表达式2：边界判定，限定循环执行次数\n\t条件表达式3：用来执行条件变化\n*/\nfor(条件表达式1; 条件表达式2; 条件表达式3)\n{\n\t//循环体\n}\n\n```\n\n#### 2.while循环\n\n```php\n/*\n\t条件表达式判断边界条件\n\t条件变化在循环体中实现\n*/\nwhile(条件表达式){\n\t//循环体\n}\n\n```\n\n#### 3.do-while循环\n\n```php\ndo{\n\t//循环体\n}while(条件表达式);\n\n```\n\n#### 4.循环控制\n\n**中断控制**：**continue;** 结束本次循环，重新开始循环.\n\n​\t**continue n;**对n层**嵌套**的循环同时执行结束本次循环的操作\n\n**终止控制**：**break;** 整个循环结束.\n\n​\t**break n;**对n层**嵌套**的循环同时执行终止整个循环的操作\n\n#### 5.流程控制（替代语法）：\n\n九九乘法表：\n\n```php+HTML\n<table border=1>\n    <?php for($i = 1; $i < 10; $i++){?>\n    \t<tr>\n    \t\t<?php for($j = 1; $j <= $i; $j++){?>\n            \t<td>\n            \t\t<?php echo $i . \" * \" . $j . \" = \" . $i*$j;?0>\n            \t</td>\n    \t\t<?php }?>\n    \t</tr>\n    <?php }?>\n</table>\n\n```\n\n使用 **for(;;): endfor; ** 替代 **for(;;){ }**\n\n```php+HTML\n<table border=1>\n    <?php for($i = 1; $i < 10; $i++):?>\n    \t<tr>\n    \t\t<?php for($j = 1; $j <= $i; $j++):?>\n            \t<td>\n            \t\t<?php echo $i . \" * \" . $j . \" = \" . $i*$j;?0>\n            \t</td>\n    \t\t<?php endfor?>\n    \t</tr>\n    <?php endfor;?>\n</table>\n\n```\n\n替代语法：\n\n```\nif：\t\tif():\t\tendif;\nswitch：\tswitch():\tendswitch;\nfor\nwhile\nforeach\n\n```\n\n## 七、文件包含\n\n文件包含四种形式：**include, require, include_once,  require_once**\n\n### （1）文件加载原理\n\n1. 在文件加载（include或者require）的时候，系统会自动的将包含文件的代码相当于嵌入到当前文件中\n2. 加载位置：在哪加载，对应的文件中代码嵌入的位置就是对应的include位置\n3. 在PHP中被包含的文件是单独进行编译的\n\nPHP文件在编译过程中如果出现了语法错误，那么会失败（不会执行）；但是如果被包含的文件有错误时，系统会执行到包含include这条语句的时候才会报错。\n\n### （2）include和include_once的区别：\n\n**include** ：系统碰到一次，执行一次，如果对同一个文件进行多次加载，那么系统会执行多次；\n\n**include_once** ：系统碰到多次，也只会执行一次。\n\n### （3）require和include的区别\n\n本质都是包含文件，唯一的区别在于**包含不到文件**的时候，报错的形式不一样。\n\n**include**的错误级别较轻（**Warning**），不会阻止代码执行。\n\n**require**的错误级别较高（**Fatal Error**），如果包含出错，require后面的代码不会执行。\n\n### （4）文件加载路径\n\n文件在加载的时候需要指定文件路径才能保证PHP正确的找到对应的文件。\n\n#### 1.绝对路径\n\n**本地绝对路径**：从磁盘的根目录开始\n\n​\tWindows：盘符c:/路径/PHP文件\n\n**网络绝对路径**：从网站根目录开始\n\n​\t/ : 相对于网站主机名字对应的路径\n\n​\tlocalhost/index.php —> D:/Server/Apache24/htdocs/PHPBasic/index.php\n\n#### 2.相对路径\n\n从当前文件所在目录开始的路径\n\n **.** 或 **./** ： **.** 表示当前文件夹\n\n **../** ：上级目录（当前文件夹的上一层文件夹）\n\n#### 3.绝对路径与相对路径的加载区别 \n\n**绝对路径**相对效率偏低，但是相对安全（路径不会出问题）。\n\n**相对路径**相对效率高些，但是容易出错（相对路径会发生改变）。\n\n### （5）文件嵌套包含\n\n文件嵌套包含：一个文件包含另一个文件，同时被包含的文件又包含了另外一个文件。\n\n嵌套包含时容易出现**相对路径错误**，相对路径（ **./** 和 **../** ）会因为文件的包含而改变。\n\n## 八、函数\n\nfunction：一种语法结构，将实现某一个功能的代码块（多行代码）封装到一个结构中，从而**实现代码的重复利用**。\n\n### （1）函数语法\n\n1.函数的定义：\n\n```php\nfunction 函数名(参数1,...){\n\t//函数体\n\treturn 结果;\t//返回值\n}\n\n```\n\n2.函数的调用：**函数的调用可以在函数定义之前**\n\n```php\n函数名(参数1,...);\n\n```\n\n3.命名规范：\n\n​\t由字母、数字和下划线组成，但不能以数字开头。\n\n​\t在一个脚本周期中，不允许出现同名函数。（通常在一个系统开发中都不会使用同名函数）\n\n### （2）参数详解\n\n#### 1.实参与形参\n\n1.形参：形式参数，不具有实际意义，在函数定义时使用的参数\n\n2.实参：实际参数，具有实际数据的参数，实在函数调用时使用的参数，**形参是实参的载体**\n\n注意：\n\n1.php中允许实参个数多于形参，但不能少于形参。\n\n2.理论上形参个数没有限制。\n\n#### 2.参数默认值：\n\ndefault value，指的是形参的默认值，在函数定义的时候，就给形参进行一个初始赋值。如果没有提供实际调用传入的参数（实参），那么形参就会使用定义时的值来进入函数内部参与运算。\n\n```php\nfunction add($num1 = 0, $num2 = 0){\n\techo $num1 + $num2;\n}\n\n```\n\n注意：\n\n默认值的定义是放在最后面的参数上的，不能左边的形参有默认值而右边的形参没有默认值。\n\n#### 3.值传递与引用传递\n\n值传递：将实参（变量或其他表达式）的结果（值）取出来赋值给形参，形参与外部实际传入的参数本身没有任何关联。\n\n引用传递：在函数定义时，说明希望能够在函数内部改变函数外部的数据，这样函数调用时会主动获取外部数据的内存地址，直接操作外部数据。\n\n```php\nfunction 函数名($值传递形参名, &$引用传递形参名){\n\t//函数体\n}\n\n```\n\n注意：函数调用时，引用传递的形参必须传入**变量**实参。\n\n### （3）函数体\n\n函数体：函数内部（大括号里面）的所有代码。\n\n### （4）函数返回值\n\nphp中所有的函数都有返回值，默认返回值为NULL。\n\n函数的返回值可以是任意类型。\n\nreturn关键字：\n\n1.return在函数内部使用：返回当前函数的结果，当前函数运行结束，return后的代码不会被执行。\n\n2.return在文件中直接使用（不在函数里面）：文件将return后面的内容（代码语句），转交给包含当前文件的位置，同时终止return后面的代码（return之后的内容不会执行），通常在系统配置文件中使用较多。\n\n### （5）作用域\n\n作用域：变量（常量）能够被访问的区域。\n\n1.变量可以在普通代码中定义\n\n2.变量也可以在函数内部定义\n\n\n\n在php中，作用域（严格来说）分为两种，但php内部还定义了一种严格意义之外的作用域：\n\n1.**全局变量**：用户普通定义的变量\n\n​\t所属**全局空间**，在php中只允许在全局空间使用，理论上在函数内部不可访问。\n\n​\t**脚本周期**：直到脚本运行结束，最后一行代码执行完。\n\n2.**局部变量**：在函数内部定义的变量\n\n​\t所属当前**函数空间**，在php中只允许当前函数自己使用。\n\n​\t**函数周期**：函数执行结束，函数在栈区中开辟独立内存空间运行。\n\n3.**超全局变量**：系统定义的变量（如预定义变量$_SERVER等）\n\n​\t所属**超全局空间**，没有访问限制，函数内外都可以访问。\n\n​\t超全局变量会将全局变量自动纳入到**$GLOBALS数组**里面，而$GLOBALS没有作用域限制，所以能够帮助在局部空间中访问全局变量：但是必须使用数组方式。\n\n```php\n$global = 'global area';\t\t//最终会被系统纳入到超全局变量中，$GLOBALS['global'] = 'global area'\n\nfunction display(){\n\tvar_dunp($GLOBALS);\t\t\t//查看数组内容\n\techo $GLOBALS['global'];\t//用下标global访问数组内容\t\n}\n\n```\n\n\n\n在php中，还有一种实现变量跨域访问的方式：**global关键字**\n\nglobal关键字：是一种在函数里面定义变量的一种方式\n\n1.如果使用global定义的变量名在外部存在（全局变量中已经存在），那么在函数内部定义的变量将指向外部已经定义的全局变量所指向的内存空间（同一个变量）。\n\n2.如果使用global定义的变量名在外部不存在，系统会自动在全局空间定义一个与此变量同名的全局变量。\n\n本质的形式：在函数的内部和外部，对一个同名变量使用同一块内存地址保存数据。\n\n```\nglobal 变量名;\t\t\t\t//定义时不能赋值\n变量名 = 值;\n\n```\n\n使用global关键字跨域访问：\n\n```php\n$global = 'global area';\n\nfunction display1(){\n\tglobal $global;\t\t\t\t//对于全局空间存在的变量\n\techo $global;\t\t\t\t//打印 global area\n}\n\nfunction display2(){\n    global $local;\t\t\t\t//对于全局空间不存在的变量\n    $local = 'inner';    \n}\n\necho $local;\t\t\t\t\t//打印 inner\n\n```\n\n\n\n### （6）静态变量\n\n静态变量：使用static关键字，用来实现**跨函数共享数据**的变量，即同一个函数被多次调用时，共享同一个变量同一个数据。\n\n```php\nfunction 函数名(){\n\tstatic $变量名 = 变量值\n}\n\n```\n\n例子：\n\n```php\nfunction display(){\n\t$local = 1;\t\t\t\t//局部变量\n\tstatic $count = 1;\t\t\t\t//静态变量\n    echo $local++, ' ', $count++, '<br/>';\n}\n\ndisplay();\t\t\t\t\t//1 1\ndisplay();\t\t\t\t\t//1 2\ndisplay();\t\t\t\t\t//1 3\n\n```\n\n原理：系统在编译php文件的时候，就会对static变量进行初始化，函数在调用的时候，static变量定义的过程会被跳过。\n\n静态变量的使用：\n\n1.统计当前函数被调用的次数\n\n2.统计函数被多次调用得到的不同结果（递归思想）\n\n### （7）可变函数\n\n可变函数：当前有一个变量所保存的值，刚好是一个函数的名字，那么就可以使用 **变量+()** 来充当函数名使用。\n\n```php\n$func = 'display';\nfunction display(){\n\n}\n$func();\t\t\t\t\t//等同于 display();\n\n```\n\n可变函数的使用：系统函数需要用户在外部定义定义一个自定义函数，但是需要传入到系统函数内部使用。\n\n```php\n//定义系统函数（假设）\nfunction sys_function($arg1, $arg2){\n\t//给指定的函数（第一个参数），求对应第二个参数值的四次方\n\t//为实际用户输入的数值进行处理\n\t$arg2 = $arg2 + 10;\n\treturn $arg1($arg2);\n}\n//定义一个用户函数：求一个数的四次方\nfunction user_function($num){\n\treturn $num * $num * $num * $num;\n}\n//求10+10的4次方\necho sys_function('user_function', 10);\n\n```\n\n### （8）匿名函数\n\n匿名函数：没有名字的函数\n\n定义与调用：\n\n```php\n$变量名 = function(){\n\t//函数体\n};\n//调用匿名函数\n$变量名();\n\n```\n\n变量保存匿名函数，本质上得到的是一个对象（Closure类）。\n\n**闭包**：closure，函数内部有一些局部变量（要执行的代码块）在函数执行之后没有被释放，是因为在函数内部还有对应的函数在引用这些局部变量（函数内部的函数：匿名函数）。\n\n```php\n//闭包函数\nfunction display(){\n\t//定义变量：局部变量\n\t$name = __FUNCTION__;\n\t\n\t//定义匿名函数\n\t//use就是将外部变量（局部变量）保留给内部使用（闭包）\n\t$innerfunc = function() use($name){\n\t\t//函数内部的函数\n        //匿名函数调用了局部变量$name\n\t\techo $name;\n\t};\n\t\n    //返回内部匿名函数\n    return $innerfunc;\n}\n\n$closure = display();\n//display()函数运行结束，但局部变量$name没有被释放,从而在外部调用内部匿名函数的时候可以被使用\n$closure();\n\n```\n\n### （9）伪类型\n\n伪类型：实际上在php中不存在的类型，但是通过伪类型可以帮助程序员更好地查看操作手册，方便学习。\n\n伪类型主要有两种（在八小类类型之外）：\n\n1.mixed：混合的，可以是多种php中的数据类型\n\n2.number：数值的，可以是任意数值类型（整型和浮点型）\n\n### （10）常用系统函数\n\n3.常用数学函数\n\n```\nmax()：指定参数中的最大值\nmin()：指定参数中的最小值\nrand()：得到一个指定区间的随机整数\nmt_rand()：与rand一样，只是底层结构不一样，效率比rand高\nround()：四舍五入\ncell()：向上取整\nfloor()：向下取整\npow()：幂运算\nabs()：绝对值\nsqrt()：平方根\n\n```\n\n4.有关函数的函数\n\n```\nfunction_exist()：判断指定的函数名字是否在内存中存在\nfunc_get_arg()：在自定义函数中获取指定index对应的参数\nfunc_get_args()：在自定义函数中获取所有的参数（数组）\nfunc_num_args()：在自定义函数中获取函数的参数数量\n\n```\n\n注意：func_get_args()和func_num_args()统计的都是实参而非形参\n\n## 九、错误处理\n\n错误处理：指的是系统（或者用户）在对某些代码进行执行的时候，发现有错误，就会通过错误处理的形式告知程序员。\n\n### （1）错误分类\n\n1.语法错误：用户书写的代码不符合php语法规范，语法错误会导致代码在编译过程中不通过，所以代码不会执行(parse error)。\n\n2.运行时错误：代码编译通过，但是代码在执行过程中会出现一些条件不满足导致的错误（runtime error）。\n\n3.逻辑错误：程序员在写代码的时候不够规范，出现了一些逻辑性的错误，导致代码正常执行，但是得不到想要的结果。\n\n### （2）错误代号\n\n所有看到的错误代号在php中都被定义成了系统常量（可以直接使用）。\n\n所有以 E 开头的错误常量（代号）其实都是由一个字节存储，然后每一种错误占据一个对应的位，错误控制因此可以使用位运算。\n\n1.系统错误\n\n```\nE_PARSE：编译错误，代码不会执行\nE_ERROR：fatal error，致命错误，会导致代码不能正确继续执行（出错的位置断掉）。\nE_WARNING：warning，警告错误，不会影响代码执行，但是可能得到意想不到的结果。\nE_NOTICE：notice，通知错误，不会影响代码执行。\n\n```\n\n2.用户错误\n\n用户在使用自定义错误触发的时候，会使用到的错误代号（系统不会用到）。\n\n```\nE_USER_ERROR\nE_USER_WARNING\nE_USER_NOTICE\n\n```\n\n3.其他\n\n```\nE_ALL：代表着所有的错误（通常在进行错误控制时候使用），建议在开发过程中（开发环境）使用。\n\n```\n\n排除通知错误：\n\n```php\nE_ALL & ~E_NOTICE\n\n```\n\n### （3）错误触发\n\n1.程序运行时触发\n\n系统自动根据错误发生后，对比对应的错误信息，输出给用户。\n\n主要针对代码的语法错误和运行时错误。\n\n2.人为触发\n\n知道某些逻辑可能会出错，从而使用对应的判断代码来触发相应的错误提示。Trigger_error(错误提示);\n\n```php\n<?php\n    \n    //处理脚本，让浏览器按照指定字符集解析\n    header('Content-type:text/html;charset=utf-8');\n    \n\t$a = 100;\n\t$b = 0;\n\tif($b == 0){\n\t\ttrigger_error('除数不能为0');\t\t\t\t\t//默认notice错误，代码会继续执行\n        trigger_error('除数不能为0', E_USER_ERROR);\t\t//设置为error，代码终止执行\n\t}\n\techo $a / $b;\n\n```\n\n### （4）错误设置\n\n#### 1.错误显示设置\n\n哪些错误该显示，以及该如何显示。\n\nphp中，有两种方式来设置当前脚本的错误处理：\n\n​\ta.php的配置文件：全局配置 php.ini 文件\n\n```\nerror_reporting：显示什么级别的错误\ndisplay_errors：是否显示错误\n\n```\n\n​\tb.在运行的php脚本中设置：在脚本中定义的配置项函数级别比配置文件高\n\n```\nint error_reporting([int $level])：设置对应的错误显示级别\nini_set('配置文件中的配置项', 配置值)：ini_set('error_reporting', E_ALL);\n\n```\n\n#### 2.错误日志设置\n\n在实际生产环境中，不会直接将错误展示给用户（不友好、不安全），一般不显示错误，而是将错误保存到日志文件中。\n\n​\ta.在php配置文件中或者代码中，设置log_errors配置项，来开启日志功能。\n\n​\tb.在php配置文件中或者代码中，设置error_log配置项来指定日志文件路径。\n\n### （5）自定义错误处理\n\n最简单的错误处理：trigger_errors()函数，该函数不会阻止系统报错。\n\nphp系统提供了一种用户处理错误的机制：用户自定义错误处理函数，然后将该函数增加到操作系统错误处理的句柄中，然后系统会在碰到错误之后，使用用户定义的错误函数。\n\n```\n<?php\n\t//处理脚本，让浏览器按照指定字符集解析\n    header('Content-type:text/html;charset=utf-8');\n\t\n\t//自定义函数\n\tfunction my_error($errno, $errstr, $errfile, $errline){\n\t\t//判断当前会碰到的错误有哪些\n\t\t//error_reporting()获取当前系统错误处理对应的级别\n\t\tif(!(error_reporting() & $errno)){\n\t\t\treturn false;\n\t\t}\n\t\t//开始判断错误类型\n\t\tswitch($errno){\n\t\t\tcase E_ERROR;\n\t\t\tcase E_USER_ERROR;\n\t\t\t\techo 'fatal error in file ' . $errfile . ' on line ' . $errline . '</br>';\n            \techo 'error info : ' . $errstr;\n\t\t\t\tbreak;\n\t\t\tcase E_WARNING;\n\t\t\tcase E_USER_WARNING;\n            \techo 'warning in file ' . $errfile . ' on line ' . $errline . '</br>';\n            \techo 'error info : ' . $errstr;\n\t\t\t\tbreak;\n            case E_NOTICE;\n\t\t\tcase E_USER_NOTICE;\n            \techo 'notice in file ' . $errfile . ' on line ' . $errline . '</br>';\n            \techo 'error info : ' . $errstr;\n\t\t\t\tbreak;\n\t\t}\n        return true;\n\t}\n    \n    //报错\n    echo $a;\n    \n    //修改错误机制\n    set_error_handler('my_error');\n    \n    //报错\n\techo $a;\n\n```\n\n## 十、字符串类型\n\n### （1）字符串定义语法\n\n------\n\n引号方式定义\n\n------\n\n1.单引号字符串\n\n```php\n$str1 = 'hello';\n\n```\n\n2.双引号字符串\n\n```php\n$str2 = \"hello\";\n\n```\n\n引号方式：比较适合定义比较短、没有结构要求的字符串\n\n双引号区别于单引号，能**识别变量**（用此方法识别变量需要保证变量独立性，如：使用**变量标识符 {$a}** ）和更多的转义字符。\n\n------\n\n结构化方式定义\n\n------\n\n3.nowdoc字符串：没有单引号的**单引号字符串**\n\n语法： \n\n```php\n$变量名 = <<<'边界符'\n    字符串内容\n边界符;\n\n```\n\n例子：\n\n```php\n$str3 = <<<'EOD'\n\thello\n\t\tworld\nEOD;\n\n```\n\n4.heredoc字符串：没有双引号的**双引号字符串**\n\n语法：\n\n```php\n$变量名 = <<<边界符\n    字符串内容\n边界符;\n\n```\n\n例子：\n\n```php\n$str4 = <<<EOD\n\thello\n\t\tworld\nEOD;\n\n```\n\n### （2）字符串转义\n\n转义：在计算机统用协议中，有一些特定的方式定义的字母，系统会特定处理，通常使用反斜杠+字母的特性\n\n\\r\\n：回车换行\n\nphp中常用的转义符号：\n\n```\n\\'：在单引号字符串中显示单引号\n\\\"：在双引号字符串中显示双引号\n\\r：回车（理论上回到当前行的首位置）\n\\n：代表新一行\n\\t：类似Tab键，输出4个空格\n\\$：在php中，$为变量符号，需要在字符串中特殊识别\n\n以上\n单引号字符串只能够识别：\\'\n双引号字符串只不能识别：\\'\n\n```\n\n### （3）字符串长度\n\n1.基本函数 strlen()：得到字符串的长度，以字节为单位\n\n​\t注意：每个汉字在utf-8字符集下占3个字节\n\n2.多字节字符串扩展模块：mbstring 扩展（mb为Multi Bytes）\n\n​\t加载扩展：php.ini 中 extension=php_mbstring.dll 语句取消注释\n\n​\t使用mb扩展带来的函数：mb_strlen($字符串变量, '字符集')\n\n​\t在 utf-8 字符集中，mb_strlen()对汉字求长度，一个汉字+1\n\n### （4）字符串相关函数\n\n1.转换函数\n\n```\nimplode()：将数组中的元素按照某个规则连接成一个字符串\nexplode()：将字符串按照某种格式进行分割，变成数组\nstr_split()：按照指定长度拆分字符串返回数组\n\n```\n\n2.截取函数\n\n```\ntrim()：默认用来去除字符串首尾的空格，也可以指定要去除的首尾的内容\nltrim()：去除字符串首内容\nrtrim()：去除字符串尾内容\nsubstr()：指定位置索引位置开始截取字符串，可以指定长度，不指定长度就截取到字符串尾\nstrstr()：从指定字符串位置开始截取字符串到最后\n\n```\n\n3.大小写转换\n\n```\nstrtolower()：全部小写\nstrtoupper()：全部大写\nucfirst()：首字母大写\n\n```\n\n4.查找函数\n\n```\nstrpos()：判断字符在目标字符串中首次出现的位置，用===判断是否出现\nstrrpos()：判断字符在目标字符串中最后出现的位置\n\n```\n\n5.替换函数\n\n```\nstr_replace()：将目标字符串中部分字符串进行替换\nstr_replace('匹配目标', '替换内容', 字符串)\n\n```\n\n6.格式化函数\n\n```\nprintf()/sprintf()\n\n```\n\n7.其他函数\n\n```\nstr_repeat()：重复某个字符串N次\nstr_shuffle()：随机打乱字符串（验证码）\n\n```\n\n## 十一、数组 array\n\n### （1）数组定义语法\n\n1.使用 array 关键字（最常用）\n\n```\n$变量 = array(元素1, key => value , ...);\n\n```\n\n2.使用中括号来包裹数据\n\n```\n$变量 = [元素1, 元素2, ...];\n\n```\n\n3.隐形定义数组：给变量加一个中括号，系统自动变成数组\n\n```\n$变量[] = 值;\t\t\t\t//默认下标为当前最大下标+1\n$变量[下标] = 值;\n\n```\n\n### （2）数组特点\n\n1.可以使用整数下标或者字符串下标\n\n​\t索引数组：数组下标都为整数\n\n​\t关联数组：数组下标都为字符串\n\n​\t混合数组：整数下标和字符串下标混合存在\n\n2.数组元素的顺序以放入顺序为准，与下标无关\n\n3.特殊值下标的自动转换\n\n​\t布尔值：true --> 1 , false --> 0\n\n​\t空：NULL --> \"\"\n\n### （3）多维数组\n\n数组里面的元素又是数组\n\n1.二维数组：数组中所有的元素都是一维数组\n\n```php\n$info = array(\n\tarray('name' => 'Jim', 'age' => 30),\n\tarray('name' => 'Tom', 'age' => 28),\n\tarray('name' => 'Lily', 'age' => 20)\n);\necho '<pre>';\nprint_r($info);\n\n```\n\n2.多维数组\n\n二维数组的数组元素中可以继续是数组，php中没有维度限制（本质上没有二维数组的定义），不建议使用三维以上的数组，会再增加访问的复杂度，降低访问效率\n\n3.异形数组（不规则数组）\n\n数组中的元素不规则，有数组也有普通基本变量\n\n在实际开发中并不常用，尽量让数组元素规则化，便于访问\n\n### （4）数组遍历\n\n#### 1.foreach 遍历\n\n```\nforeach($数组变量 as [$下标 =>] $值){\n\t//通过$下标访问元素的下标\n\t//通过$值来访问元素的值\n}\n\n```\n\n如果是关联数组一般需要下标，如果是索引数组一般不需要下标。\n\n例子：\n\n```php\n$arr = array(1,2,3,4,5,6,7,8,9,10);\n\nforeach($arr as $v){\n\techo $v , '<br/>';\n}\n\nforeach($arr as $k => $v){\n    echo 'key:',$k,'==value: ',$v,'<br/>';\n}\n\n```\n\nforeach 遍历原理：\n\n数组内部有一个指针，默认指向数组的第一个元素，foreach利用指针去获取数据，同时移动指针。\n\n1.foreach重置指针，让指针指向第一个元素\n\n2.进入foreach循环，通过指针取得当前第一个元素，将下标和值取出，放入对应的下标变量和值变量中\n\n3.指针下移（+1）\n\n4.进入循环体，执行代码\n\n5.重复2 3 4，直到在第二步中指针取不到内容（指针指向数组最后）\n\n#### 2.for 循环遍历\n\n使用条件：\n\n1.已知边界条件（起始、结束）\n\n2.已知数组长度， count() 函数\n\n3.要求数组元素下标是有条件(规律)的变化\n\n```php\n$arr = array(1,2,3,4,5,6,7,8,9,10);\nfor($i = 0, $len = count($arr);$i < $len; $i++)\n{\n\techo 'key:',$i,'==value: ',$arr[$i],'<br/>';\n}\n\n```\n\n#### 3.while配合each和list遍历数组\n\n**each函数**：\n\neach能够从一个数组中获取当前数组指针所指向的元素的下标和值，拿到之后，将数组**指针下移**，同时将拿到的元素下标和值以一个**4个元素的数组返回**，此4个元素的数组：\n\n​\t0下标 => 取得元素的下标值\n\n​\t1 下标 => 取得的元素\n\n​\tkey下标 => 取得元素的下标\n\n​\tvalue下标 => 取得元素的值，\n\n如果each取不到元素，返回false\n\n```php\n$arr = array(1,'name'=> 'Tom',3,'age'=>30);\n    echo '<pre>';\n    print_r(each($arr));\n    print_r(each($arr));\n    print_r(each($arr));\n    print_r(each($arr));\n    var_dump(each($arr));\n\n/*结果：\nArray\n(\n    [1] => 1\n    [value] => 1\n    [0] => 0\n    [key] => 0\n)\nArray\n(\n    [1] => Tom\n    [value] => Tom\n    [0] => name\n    [key] => name\n)\nArray\n(\n    [1] => 3\n    [value] => 3\n    [0] => 1\n    [key] => 1\n)\nArray\n(\n    [1] => 30\n    [value] => 30\n    [0] => age\n    [key] => age\n)\nbool(false)\n*/\n\n```\n\n\n\n**list结构**：\n\nlist是一种结构，不是一种函数（没有返回值），list提供一个或一组变量去从一个数组中取得元素值，然后依次存放到对应的变量中（相当于批量为变量赋值，值来源于数组）。\n\n条件：list必须从**索引数组**中获取数据\n\n```php\n\t$arr = array(3,2 =>1);\n    list($first) = $arr;\n    var_dump($first);\t\t\t//int(3)\n\n```\n\n错误使用：变量多于数组元素，没有指定从0到指定变量的下标的数组元素\n\n```php\n    $arr = array(3,2 =>1);\n    list($firs, $second) = $arr;\n    var_dump($first, $second);\n\n/*\nNotice: Undefined offset: 1 in --\\arr.php on line --\nint(3) NULL\n$arr[1]不存在，$arr[2] == 1，\n$second变量对应下标为1的元素，\nlist找不到下标为1的元素，故出错\n*/\n\n```\n\n\n\n**list与each配合**：each一定有两个元素就是0下标和1下标元素\n\n```php\n$arr = array(1,'name'=> 'Tom',3,'age'=>30);\n\nwhile(list($key,$value) = each($arr)){\n    echo 'key:', $key , '==value: ', $value , '<br/>';\n}\n\n/*\nkey:0==value: 1\nkey:name==value: Tom\nkey:1==value: 3\nkey:age==value: 30\n*/\n\n```\n\n### （5）数组相关函数\n\n#### 1.排序函数\n\n都是按照ASCII码进行比较\n\n```\nsort()：顺序按元素值排序，从低到高，下标重排\nrsort()：逆序\nasort()：顺序按元素值排序，下标对应关系保留\narsort()\nksort()：顺序按键名（下标）排序，下标对应关系保留\nkrsort()\nshuffle()：随机打乱数组元素，下标重排\n\n```\n\n以上函数返回值均为bool类型，执行后直接修改源数组\n\n#### 2.指针函数\n\n```\nreset()：重置指针，将数组指针回到首位，返回元素值\nend()：重置指针，将数组指针指到最后一个元素，返回元素值\nnext()：将数组中的内部指针+1，返回下一个元素的值\nprev()：将数组中的内部指针-1，返回上一个元素的值\ncurrent()：获取当前指针对应的元素值\nkey()：获取当前指针对应的键名（下标）\n\n```\n\n注意：如果使用next()或prev()导致指针移出数组，将无法再次使用next()和prev()使指针回到正确的位置，此时只能通过reset()或end()重置指针。\n\n#### 3.其他函数\n\n```\ncount()：统计数组中元素的数量\n\narray_push()：在数组尾部加入一个元素\narray_pop()：从数组尾部取出一个元素\narray_unshift()：在数组开头加入一个元素\narray_shift()：从数组开头取出一个元素\n\narray_reverse()：将数组元素顺序翻转\nin_array()：判断一个元素在数组中是否存在\n\narray_keys()：获取一个数组的所有下标，返回一个索引数组\narray_values()：获取一个数组的所有值，返回一个索引数组\n```","tags":["PHP"]},{"title":"软件架构与设计模式学习笔记","url":"/2019/06/12/软件架构与设计模式学习笔记/","content":"\n# （一）课程简介&概述\n\n对于大型、复杂、软件密度高(software-intensive)的系统而言，系统的宏观结构设计成为系统成败的决定性关键因素。\n\n## 一、什么是软件体系结构\n\n软件体系结构（Software Architecture）是：\n\n1. 解决日益复杂的软件系统的分析不设计问题\n2. 刻画大型复杂软件系统的静态结构与动态行为\n3. 构造更大更复杂软件系统的有效工程方法\n\n的一种软件设计技术与软件工程方法。\n\n\n\n一个软件系统的体系结构是指它所包含的**计算构件**和这些**构件间的交互作用**。\n\n即：Software Architecture= SA = {components, connectors}\n\nComponent（构件/组件）：系统的逻辑与功能结构组成单元。\n\nConnector（连接件）：构件间相互交互的机制与规则。\n\n## 二、各个时期的软件\n\n### （1）软件的机器指令时代：\n\n这个时代的程序就是若干条机器指令所组成的一段顺序执行的计算指令，软件的结构表现为指令之间的顺序结构。\n\n### （2）软件的汇编与早期的高级语言时代：\n\n这个时代的软件的宏观结构体现为主-子程序的调用与被调用的结构。\n\n### （3）软件的面向结构时代：\n\n在面向结构的软件开发时代，模块的聚集和嵌套形成层层调用的软件宏观结构。人们在设计软件时，开始先从软件模块的抽象结构粒度上考虑软件系统的宏观结构。\n\n### （4）软件的面向对象时代：\n\n对于面向对象的软件系统，包（Package）或名字空间（Namespace）是对象的结构化组织，而系统的包结构或名字空间的划分来体现软件的一种宏观静态结构。\n\n## 三、理解软件体系结构\n\n### （1）宏观与微观\n\n系统体系结构设计（宏观）：体系结构模型\n\n系统详细设计（微观）：详细设计模型\n\n### （2）自顶向下和自底向上\n\n对系统的设计过程：由总体到局部（Top-down）\n\n系统实现的过程：先局部再整体（Bottom-up）\n\n\n\n# （二）软件体系结构基础\n\n## 一、软件体系结构的核心概念模型\n\n### （1）Component（构件）\n\nComponent（构件）：系统的逻辑与功能结构单元。\n\n------\n\n构件是一种抽象概念表述。是对以各种具体实现技术的系统结构组成元素（如子系统、模块、包等）的统称。\n\n构件是对系统功能集中的一个功能子集的结构化封装与实现。每个构件对于系统而言，应具有一定功能性。\n\n------\n\n构件通过其端口（Port）与外部环境交互。构件的端口（Port）表示了构件和外部环境的交互作用点。\n\n端口（Port）：构件与外界的交互作用点，是构件的外部可见特征（Visible Properties）。\n\n------\n\n构件的可分解性：\n\n构件的可分解性：\n\n原子（atom）构件：不再需要进行分解的构件。\n\n复合（composite）构件：需要再进行分解的构件。\n\n------\n\n分类：\n\n根据功能层次：基础构件、中层构件、高层构件。\n\n根据复用度：通用构件、专用构件。\n\n根据功能类别：数据构件、界面构件、控制构件、安全构件。\n\n### （2）Connector（连接件）\n\nConnector（连接件）：构件间相互交互的机制或规则。\n\n机制：是指连接件的具体实现形式：如过程调用、共享存储区。\n\n规则：是指构件使用连接件应遵循的规范。如对“过程调用”这种连接件其规则是指调用的接口参数形式、共享存储区则是指其本身的数据存储结构。\n\n------\n\n构件在交互过程中体现为不同的角色。\n\n一个连接件所涉及的角色可能是二元的，也有多元的。\n\n------\n\n方向性：单向和双向。有返回值的函数调用为双向连接。\n\n性能特性：同步/异步连接、开放/安全连接、串行/并行 ...\n\n### （3）Configuration（配置）\n\nConfiguration（配置）：构件与连接件的装配规约（Assemble Specification）。\n\n描述了构件通过连接件相互交互所形成的逻辑拓扑结构（Topology）。\n\n定义了构件、连接件的使用规则与约束。\n\n------\n\n相同的构件集与连接件集，通过不同的配置可形成不同结构形态的软件体系结构：\n\n构件的端口与连接件的角色之间的关联关系；复合构件与其子构件的嵌套包含关系。\n\n## 二、软件体系结构分析设计的两种基本方法：\n\n### （1）分解（Decomposition）\n\n按照系统功能分解的方式，将系统功能进行分解，每一个相对独立的功能分解模块形成系统结构的一个功能构件。\n\n### （2）组合（Composition）\n\n考虑系统的各功能构件间的相互关系，通过什么样的连接机制实现将各个独立的构件形成一个整体系统。\n\n## 三、系统架构的多维度分解模型：\n\n业务域分解、功能域分解、技术域分解、涉众域分解。\n\n架构分解过程模型：迭代的过程模型。\n\n## 四、软件体系结构的评价\n\n### （1）软件体系结构的功能特性\n\n软件体系结构的功能特性（Functional Property of the SA）：软件体系结构对软件需求规范中所定义的功能需求满足程度。\n\n### （2）软件体系结构的非功能特性\n\n软件体系结构的非功能特性（Non-functional Property of the SA）：软件体系结构对软件需求规范中所定义的非功能需求满足程度。\n\n非功能特性体现了**软件的质量**，决定了一个软件系统的架构设计优劣。\n\n------\n\n分为：运行期的非功能特性、开发期的非功能特性。\n\n运行期的非功能特性：性能、安全性、易用性、可用性、可伸缩性、互操作性、可靠性、健壮性。\n\n开发期的非功能特性：易理解性、可扩展性、可重用性、可测试性、可维护性、可移植性。\n\n# （三）软件体系结构建模\n\n## 一、体系结构的模型\n\n从不同的视角（view-point），可以刻画系统的体系结构不同侧面。\n\n每一个不同视角的刻画均是对系统体系结构的一个描述，我们往往需要从不同视角来描述一个系统的体系结构。\n\n## 二、“4+1”视图模型\n\n​\tBy: Philippe Kruchten (1995)\n\n------\n\n使用多个并发的视图来组织软件架构的描述，每一个视图只关心软件体系结构的一个侧面，5个视图结合在一起才能完整反映软件体系结构的全部内容。\n\n### （1）Logic View（逻辑视图）\n\nLogic View（逻辑视图）：基于功能需求抽象，刻画系统的静态结构模型。\n\n视角：功能需求的分析理解与抽象；\n\n关注点：基于软件的功能性需求，是系统功能的抽象结构表述，关注系统提供给最终用户的功能。\n\n### （2）Development View（开发视图）\n\nDevelopment View（开发视图）：考虑开发技术、过程与组织，刻画系统的开发管理结构模型。\n\n视角：软件的开发实现；\n\n关注点：是软件体系结构的逻辑视图在具体实现阶段的表示，关注软件实现的技术与组织管理要求及约束。\n\n### （3）Process View（进程视图）\n\nProcess View（进程视图）：刻画系统的运行时的结构模型。\n\n视角：软件运行时(Run-time)的结构形态；\n\n关注点：基于软件的非功能性需求，是软件系统运行时的动态结构，关注的是系统非功能性需求的满足。\n\n### （4）Physical View（物理视图）\n\nPhysical View（物理视图）：逻辑视图中的各功能构件在安装部署环境中的映射，刻画系统的安装部署结构模型。\n\n视角：软件在实际安装部署环境中的结构形态；\n\n关注点：基于软件的非功能性需求，是软件系统安装运行时的动态结构，关注的是系统非功能性需求的满足。\n\n### （5）Scenarios View（场景视图）\n\nScenarios View（场景视图）：从系统使用的角度对系统结构的描述。它反映的是在完成一个系统功能时，系统各功能构件间的交互关系。\n\n视角：用户视角；\n\n关注点：基于软件的功能性需求，关注的是在完成一个系统功能时，系统各功能构件间的协作关系，增加设计的可理解性，为其它视图的分析设计服务。\n\n# （四）典型的软件体系结构风格\n\n## 一、管道-过滤器体系结构风格 (Pipe-Filter Style)：\n\n构件类型: 过滤器（Filter），数据处理构件\n\n连接件类型: 管道（Pipe），过滤器间的连接件\n\n------\n\n1. 每个处理步骤封装在一个过滤器构件中\n2. 数据通过过滤器之间的管道传输\n3. 重组过滤器可以建立相关的系统族（不同数据处理顺序或功能）\n\n------\n\n逻辑视图：\n\n系统输入：文本文件，其他的数据源(Data Source)\n\n系统输出：数据宿/数据池（Data Sink）\n\n管道：负责实现相邻步骤之间的数据流动\n\n过滤器：数据流的独立处理构件，负责丰富、提炼或转换它的输入数据\n\n------\n\n过滤器的工作方式：\n\n【被动过滤器（Passive Filter）】\n\n- 过滤器从前一个过滤器或数据源中拉出（pull）数据\n- 过滤器把输出数据压入（push）后一个过滤器或数据池（Data Sink）\n\n【主动过滤器（Active Filter）】\n\n- 过滤器以循环的方式工作，从前一个过滤器或数据源拉出输入数据并将其输出数据压入下一个过滤器或数据池（Data Sink）\n\n------\n\n管道(Pipe)：\n\n表示过滤器之间的连接；数据源和第一个过滤器之间的连接；以及最后的过滤器和data sink之间的连接\n\n如果管道连接两个主动过滤器,那么管道需要迚行缓冲和同步\n\n管道可以实现数据在过滤器之间的数据转换，将一个过滤器的输出数据格式转换为其后接的过滤器的数据输入格式\n\n------\n\n应用场景（Context）：\n\n- 处理或者转换输入数据流\n- 对数据的处理可以容易地分成几个处理步骤\n- 系统的升级要求可以通过替换/增加/重组处理步骤实现，有时甚至由使用者完成操作\n- 不同的处理步骤间不共享信息\n\n------\n\n优点：\n\n1. 高内聚和低耦合\n2. 支持过滤器配置实现可扩展性/可伸缩性（Flexibility）\n3. 支持过滤器构件的重用\n4. 有利于系统的维护与演化更新（Evolution）\n5. 可支持局部的并行处理以提高效率\n\n------\n\n缺点：\n\n1. 增量式处理数据时，存在效率问题\n2. 数据格式转换的问题：数据转换额外开销\n3. 不适合交互式应用系统\n\n## 二、基于事件的隐式调用风格 (Event-Based Implicit Invocation Style)\n\n又称：**事件驱动架构（Event Driven Architecture, EDA）**\n\n------\n\n**显式调用（直接耦合）**\n\n构件之间的交互是建立在彼此知道对方端口\n\n构件的交互是固定的、预先设计的\n\n**隐式调用（间接耦合）**\n\n构件间的交互不是固定的、预先未知\n\n构件间交互无需彼此感知（不知道对方的端口）\n\n------\n\n采用离散、异步的事件机制实现系统的构件间的松散、间接耦合的交互：\n\n1. 系统预先设计定义一套事件主题（Event Scheme）\n2. 系统中的其它构件预先注册一个或多个事件主题\n3. 系统中的某个构件触发一个或多个事件\n4. 当一个事件被触发，系统将事件发布给事先注册了该事件主题的所有构件\n5. 这样，某个构件上的一个或多个事件的触发就导致了系统中其它构件对事件的响应\n\n------\n\n构件类型: 事件源(Event Source)、事件处理者(Event Handler)、事件分发者(Event Dispatcher)\n\n连接件类型：事件（Event）机制\n\n------\n\n应用场景（Context）：适用于异步、并发性的系统\n\n1. 对事件的处理顺序无要求的系统\n2. 事件的处理要求具有很好的灵活性\n3. 非集中式控制的软件系统\n\n------\n\n优点：\n\n系统具有很好的灵活性，系统易于伸缩扩展\n\n------\n\n缺点：\n\n1. 系统控制权的问题：无中心控制系统\n2. 数据的交换问题：一些情况下，基于事件的系统必须依靠一个共享的仓库进行交互。在这些情况下，全局性能和资源管理便成了问题。\n3. 事件处理顺序控制问题 \n\n## 三、分层体系结构风格 (Layered Style)\n\n应用场景（Context）：\n\n1. 一个需要分解的大系统\n\n   系统的显著特征是混合了低层与高层问题\n\n   系统的需求本身定义了多个层次上的需求\n\n2. 系统规格说明描述了高层任务，并希望可移植性\n\n3. 高层任务到平台的映射不是直接的\n\n4. 系统需要满足以下非功能性特性：\n\n   后期源代码的改动应该不影响到整个系统\n\n   系统的各个部分应该可以替换。构件应该可以有不同的实现而不影响其他的构件\n\n   提高构件的内聚性\n\n   复杂构件的进一步分解\n\n   设计和开发系统时，工作界限必须清楚     \n\n------\n\n优点：\n\n1. 层的可重用性\n2. 标准化的支持\n3. 局部依赖特性\n4. 可替换性\n\n------\n\n缺点：\n\n1. 层间的依赖性\n2. 当对低层的修改由于某种原因影响了高层的时候，可能引起底层之上的多个层次\n3. 效率问题：过多的层次造成从最上层到最下层需要进行逐层的交互等\n\n## 四、仓库风格 (Repository Style)\n\n以数据为中心（Data-Center）的体系结构风格\n\n------\n\n数据中心定义了一种共享的数据结构\n\n构件之间通过数据中心分布式协同工作\n\n------\n\n构件类型：独立构件（Independent Component）、 仲裁者（Mediator）\n\n连接件类型：仓库（Repository）\n\n------\n\n两种类型：\n\n被动仓库：Database（数据库），由独立构件访问存取仓库来驱动系统运行\n\n主动仓库：Blackboard（黑板），由仓库的数据或状态来触发独立构件做相应的处理，驱动系统运行\n\n------\n\n优点：\n\n1. 便于多构件间共享大量数据，而不必关心数据是何时产生的、由谁提供的，以及通过何种途径来提供\n2. 便于将新的构件作为知识源添加到系统中来（Blackboard风格）\n\n------\n\n缺点：\n\n1. 共享数据结构的修改变得非常困难\n2. 需要同步机制和加锁机制来保证共享数据的完整性和一致性，增大了系统设计的复杂度\n\n# （五）GRASP\n\nGRASP\n\nGeneral Responsibility Assignment Software Principles\n\n通用职责分配软件原则 \n\n核心思想：职责分配（Responsibility Assignment）\n\n------\n\n9个基本原则：\n\n信息与家(Information expert)\n\n创建者(Creator)\n\n高内聚(High Cohesion)\n\n低耦合(Low Coupling)\n\n控制者(Controller)\n\n多态（Polymorphism）\n\n纯虚构（Pure Fabrication）\n\n间接性（Indirection）\n\n变化预防（Protected Variations）\n\n# （六）创建型设计模式（Creational Patterns）\n\n## 一、工厂方法模式（Factory Method）\n\n为某一个产品族对象的创建，定义统一的Factory Method接口，并由子类具体实现对象创建。\n\n### （1）Context(应用场景)\n\n1. 当一个类不知道它所需要的对象的类时：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可\n2. 当一个类希望通过其子类来指定创建对象时：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展\n3. 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中\n\n### （2）参与者\n\n1. 抽象产品类 Product\n2. 具体产品类 ConcreteProduct\n3. 抽象工厂类 Creator\n4. 具体工厂类 ConcreteCreator \n\n### （3）优点\n\n1. 为一组相关或相似对象（产品族）的创建提供了统一的创建接口（工厂方法）\n2. 将产品族对象与使用者（Client）之间解耦，使用者无需了解产品族对象创建知识就可获得和使用产品族对象\n\n### （4）缺点\n\n需要抽象工厂类和其相应的子类作为工厂方法的定义和实现，如果设计确实需要抽象工厂类和子类存在，则很好；否则的话，需要增加抽象工厂类与其子类\n\n## 二、抽象工厂模式（Abstract Factory）\n\n解决多个产品族对象的创建工作，专门定义一个用于创建这些对象的接口(基类)。客户只需与这个基接口打交道，不必考虑实体类的类型\n\n### （1）Context(应用场景)\n\n1. 一个系统不要求依赖产品类实例如何被创建、组合和表达\n2. 这个系统有多个系列产品，而系统中只消费其中某一系列产品\n3. 系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现 \n\n### （2）参与者\n\n1. 抽象产品族（Abstract Product）\n2. 抽象产品（Product）\n3. 具体产品（Concrete Product）\n4. 抽象工厂（Factory）\n5. 具体工厂（Concrete Factory）\n\n### （3）优点\n\n1. Concrete Factory中的工厂方法把产品对象创建封装起来，并将具体的产品类与Client分离\n2. 保证产品族对象创建接口的一致性（统一的产品族对象创建接口）\n\n### （4）缺点\n\nConcrete Factory对象的工厂方法数目对应product种类数目，增加新的product种类比较困难，要影响到factory的基类，进而影响到所有的子类\n\n## 三、原型模式（Prototype）\n\n以一个已有的对象作为原型，通过它来创建新的对象。在增加新的对象的时候，新对象的细节创建工作由自己来负责，从而使新对象的创建过程与Client隔离开来\n\n### （1）Context(应用场景)\n\n1. 当产品的创建过程要独立于系统时\n2. 当产品的类型是在运行时被指定的情况下\n3. 避免创建一个与product层次平行的factory层次时\n4. 当产品类的实例只能是几种确定的不同实例状态中的一种 \n\n### （2）参与者\n\n1. 原型类（Prototype）\n2. 具体原型类（ConcretePrototype）\n3. 用户类（Client） .\n\n## 四、单例模式（Singleton）\n\n确保1个类只有1个实例化对象，提供一个全局访问点\n\n### （1）Context(应用场景)\n\n1. 类必须只有一个实例，并且必须可以从已知的访问点对客户端进行访问\n2. 当唯一的实例应该通过子类进行扩展时，客户机应该能够在不修改代码的情况下使用扩展实例\n\n### （2）参与者\n\n单例类（Singleton） .\n\n### （3）评价：\n\n1. 提供了一种全局化的单一对象实例设计方法\n2. 在单态设计模式基础上，可扩展设计受限数目的对象实例创建\n\n## 五、小结\n\n1. 工厂方法模式Factory Method：通过一个一致化的factory method完成产品对象的创建\n2. 抽象工厂模式Abstract Factory：基于多个factory method实现多个product族对象的创建\n3. 原型模式Prototype：通过product原型来clone创建product对象\n4. 建造者模式Builder：完成一个包含多个子对象的复合对象的构造\n5. 单例模式Singleton：Product类的单对象实例创建\n6. Finder：把对象的获取过程与客户隔离开\n\n# （七）结构型设计模式（Structural Patterns）\n\n## 一、适配器模式（Adapter）\n\n定义一个包装类，用于包装不兼容接口的对象\n\n### （1）作用\n\n把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作\n\n### （2）Context(应用场景)\n\n1. 系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作\n2. 多个组件功能类似，但接口不统一且可能会经常切换时，可使用适配器模式，使得客户端可以以统一的接口使用它们\n\n### （3）参与者\n\n1. 适配器 Adapter\n2. 适配者 Adaptee\n3. 客户类 Client\n4. 目标类 Target\n\n### （4）优点\n\n更好的复用性；透明、简单；更好的扩展性；解耦性；符合开放-关闭原则\n\n### （5）缺点\n\n过多的使用适配器，会让系统非常零乱，不易整体进行把握\n\n### （6）分类\n\n#### 1.类的适配器模式 class adapter\n\nAdapter与Adaptee是继承关系\n\n无法适配Adaptee的子类\n\n可以重载Adaptee的行为\n\n#### 2.对象的适配器模式 object adapter\n\nAdapter与Adaptee是委派关系\n\n可以适配Adaptee的所有子类\n\n## 二、组合模式（Composite）\n\n将对象组合到树结构中以表示部分-整体层次结构。Composite允许客户端统一地处理单个对象和对象的组合 \n\n### （1）参与者\n\nClient, Component, Leaf, Composite\n\n### （3）Context(应用场景)\n\n1. 表示对象的部分-整体层次结构\n2. 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象\n\n### （4）优点\n\n1. 定义了包含leaf对象和composite对象的类层次接口——递归结构\n2. 客户一致地处理复合对象和单个对象\n3. 易于增加新类型的组件\n\n### （5）缺点\n\n很难限制组合中的组件：有时你希望一个组合只能有某些特定的组件。使用Composite时，你不能依赖类型系统施加这些约束，而必须在运行时刻进行检查 \n\n## 三、小结\n\n1. Adapter：用于两个不兼容接口之间的转接\n2. Bridge：用于将接口的抽象与多个可能的实现连接起来\n3. Facade：用于为复杂的子系统定义一个新的简单易用的接口\n4. Composite：用于构造对象组合结构\n5. Decorator：用于为对象增加新的职责（修改对象的接口）\n6. Proxy：为目标对象提供一个代理者\n7. Flyweight：针对细粒度对象的一种全局控制手段。\n\n# （八）行为型设计模式（Behavioral Patterns）\n\n## 一、命令模式（Command）\n\n将请求封装为对象，从而允许您用不同的请求、队列或日志请求参数化客户机，并支持可撤消操作\n\n### （1）Context(应用场景)\n\n1. 需要封装表示对象间的调用交互\n2. 需要实现对象间交互调用的管理\n3. 需要支持对象间交互调用的undo/redo\n4. 记录对象间交互调用以便系统回滚\n5. 需保证对象间交互的事务完整性\n\n### （2）评价\n\n1. 对象间调用交互的解耦\n2. 支持对象间交互的redo/undo – 调用重用\n3. 组合对象间的多个调用交互--宏调用/批处理\n4. 易扩展对象间交互–通过继承定义新的Command对象 .\n\n## 二、迭代器模式（Iterator）\n\n用于支持集合对象的遍历操作，而无需暴露集合对象的内部表示\n\n### （1）Context(应用场景)\n\n1. 访问集合对象而无需暴露其内部存储结构\n2. 可提供多种遍历操作方法\n3. 为不同遍历操作方法提供一个统一的接口形式\n\n### （2）参与者\n\n1. 迭代器（Iterator）\n2. 具体迭代器（ConcreteIterator）\n3. 集合（Aggregate）\n4. 具体集合（ConcreteAggregate）\n\n### （3）评价\n\n1. 支持多种集合遍历\n2. 迭代器简化了集合接口\n3. 一个集合上可以有多种遍历\n\n## 三、观察者模式（Observer）\n\n支持对象间1对多的交互调用方式\n\n### （1）Context(应用场景)\n\n1. 当一个抽象有两个方面，一个依赖于另一个时。将这些方面封装在单独的对象中，可以独立地改变和重用它们\n2. 当一个对象的更改需要更改其他对象，而您不知道需要更改多少对象时\n3. 当一个对象应该能够通知其他对象而不需要假设这些对象是谁。换句话说，您不希望这些对象紧密耦合\n\n### （2）参与者\n\n1. Subject: 目标\n2. ConcreteSubject: 具体目标\n3. Observer: 观察者\n4. ConcreteObserver: 具体观察者\n\n### （3）评价\n\n1. 抽象目标与观察者之间的耦合\n2. 支持广播\n3. 意想不到的更新\n\n## 四、小结\n\n1. Strategy、Iterator、Mediator、State、Command：用一个对象来封装某些特性，比如变化、交互、状态、行为、命令\n2. Observer：建立起subject和observer之间的松耦合连接\n3. Mediator：把约束限制集中起来，中心控制\n4. Command：侧重于命令的总体管理\n5. Chain of Responsibility：侧重于命令被正确处理\n6. Interpreter用于复合结构中操作的执行过程 ","tags":["设计模式"]}]