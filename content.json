{"meta":{"title":"FlowerMushroom Blog","subtitle":"拂水飘绵送行色 应折柔条过千枝","description":"FlowerMushroom的博客","author":"FlowerMushroom","url":"https://flowermushroom.github.io","root":"/"},"pages":[{"title":"Tags","date":"2019-07-27T03:08:01.409Z","updated":"2019-07-27T03:08:01.409Z","comments":true,"path":"tags/index.html","permalink":"https://flowermushroom.github.io/tags/index.html","excerpt":"","text":""},{"title":"About","date":"2019-06-30T16:00:00.000Z","updated":"2019-07-27T03:08:51.228Z","comments":true,"path":"about/index.html","permalink":"https://flowermushroom.github.io/about/index.html","excerpt":"","text":""}],"posts":[{"title":"初学python2.7（五）数据结构","slug":"初学python2-7（五）数据结构","date":"2019-12-17T02:21:00.000Z","updated":"2019-12-17T02:28:25.169Z","comments":true,"path":"2019/12/17/初学python2-7（五）数据结构/","link":"","permalink":"https://flowermushroom.github.io/2019/12/17/初学python2-7（五）数据结构/","excerpt":"","text":"数据结构 Learn from python2.7 official documentation 5.1 ListA list of list object methods： 1234567891011121314151617181920212223242526272829#在列表末尾添加一个项目list.append(x)#向列表末尾附加给定列表的所有项list.extend(L)#在列表给定列表的index位置插入新元素list.insert(index, x)#从列表中移除value=x的项，当不存在时error#error信息：ValueError: list.remove(x): x not in listlist.remove(x)#从列表删除给定index位置的元素并返回它#如果没有给出index，将删除列表最后一个元素list.pop([index])#返回列表种第一个值为x的元素的索引，不存在时errorlist.index(x)#返回值为x的元素在列表中出现的次数list.count(x)#对列表元素进行排序，参数可用于自定义排序#默认从小到大排序list.sort(cmp=None, key=None, reverse=False)#翻转列表元素顺序（无返回值）list.reverse() 5.1.1 List作为stack栈将列表尾部作为栈顶，使用方法： 12list.append(x)list.pop() 5.1.2 List作为Queue队列由于在List的开头(index==0)插入或弹出元素十分低效，若要实现一个Queue，可使用collections.deque。deque结构被设计成可以快速地从两端插入或弹出元素。 12345678910#添加引用from collections import deque#构造方法deque([\"a\",\"b\",\"c\"])#队尾插入deque.append(x)#队首弹出deque.popleft() 5.1.3 函数式编程Functional Programming工具5.1.3.1 filter(function, sequence)函数filter()返回sequence中使function返回值为true的元素组成的新List。 注意：sequence为str，unicode或者tuple时，filter()的返回值将会是同样的类型。 12345#使用filter返回能被3或5整除的数def f(x): return x % 3 == 0 or x % 5 == 0filter(f, range(2, 25))&gt;&gt;&gt; [3, 5, 6, 9, 10, 12, 15, 18, 20, 21, 24] 5.1.3.2 map(function, sequence)函数map()为sequence中的每个元素item调用function(item)，返回由function(item)结果组成的List。 1234#使用map计算三次方def cube(x): return x*x*xmap(cube, range(1, 11))&gt;&gt;&gt; [1, 8, 27, 64, 125, 216, 343, 512, 729, 1000] 一个或多个sequence可以被作为参数传递，这取决于函数function参数列表中的参数数量。如果某个sequence的长度小于其他，相应项取None。 5.1.3.3 reduce(function, sequence [,starting value])函数reduce()从sequence中选取前两项作为function的参数，之后每次用前一次function的返回值和sequence的下一项作为function的参数，如此迭代整个sequence，返回唯一的结果。 1234#使用reduce计算1-10的和def add(x, y): return x+yreduce(add, range(1, 11))&gt;&gt;&gt; 55 注意：当sequence只有一个元素时，直接返回其值；当sequence为空时，将会引发异常（TypeError: reduce() of empty sequence with no initial value）。 避免sequence=[]时出现异常的做法，是使用reduce()的第三个参数作为starting value，第一次迭代将使用次参数和sequence的第一个值。 使用第三个参数的例子： 1234567def sum(seq): def add(x,y): return x+y return reduce(add, seq, 0)&gt;&gt;&gt; sum(range(1, 11))55&gt;&gt;&gt; sum([]) #此处如果调用reduce方法没使用第三个参数0，将会抛出异常0 注意：sum(sequence)已作为python的内置函数提供，功能相同。 5.1.4 列表推导式List Comprehensions列表推导式提供了更简单的创建列表的方法。 语法：[表达式 for子句 零个或多个for子句或if子句] 1234567#创建一个平方列表squares = [x**2 for x in range(10)]&gt;&gt;&gt; [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]#返回两个序列中不重复元素的组合[(x, y) for x in [1,2,3] for y in [3,1,4] if x != y]&gt;&gt;&gt; [(1, 3), (1, 4), (2, 3), (2, 1), (2, 4), (3, 1), (3, 4)] 应用复杂的表达式和嵌套函数： 123from math import pi[str(round(pi, i)) for i in range(1, 6)]&gt;&gt;&gt; ['3.1', '3.14', '3.142', '3.1416', '3.14159'] 列表推导式的嵌套： 1234567matrix = [ [1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12],][[row[i] for row in matrix] for i in range(4)]&gt;&gt;&gt; [[1, 5, 9], [2, 6, 10], [3, 7, 11], [4, 8, 12]] 注意：zip([iterable, ...])已作为python的内置函数提供，功能相同。 5.2 del语句del语句可用于从给定index的列表中删除项item，还可用于从列表中删除切片slices或清除整个列表。 1234567891011121314#删除index==0的itemdel lst[0]#删除2&lt;=index&lt;4的slicesdel lst[2:4]#清空整个列表lstdel lst[:]&gt;&gt;&gt; lst == []#清除整个列表lstdel lst#此后再次引用lst将报错&gt;&gt;&gt; NameError: name 'lst' is not defined 5.3 元组Tuple和序列SequenceTuple和Sequence是两种标准序列类型（standard sequence data type）。 之前介绍的List和Str是属于Sequence数据类型中的两种，所以列表和字符串之间有很多共同特性。 这里介绍元组Tuple，一个元组由几个被逗号隔开的值组成： 12345t = 12345, 54321, 'hello!'print t&gt;&gt;&gt; (12345, 54321, 'hello!')print t[0]&gt;&gt;&gt; 12345 元组可以是嵌套的（nested）： 123u = t, (1, 2, 3, 4, 5)print u&gt;&gt;&gt; ((12345, 54321, 'hello!'), (1, 2, 3, 4, 5)) 元组本身的元素一旦创建将是不可改变的（immutable），给元组中的一个单独的元素赋值将引发异常： 12t[0] = 88888&gt;&gt;&gt; TypeError: 'tuple' object does not support item assignment 但，元组可以包含可改变的（mutable）对象： 1234v = ([1, 2, 3], [3, 2, 1])v[0][0] = 0print v&gt;&gt;&gt; ([0, 2, 3], [3, 2, 1]) 构造包含0个或1个元素的元组： 12345#构造空元组empty = ()#构造含有一个元素的元组singleton = 'hello', 之前使用语句t = 12345, 54321, &#39;hello!&#39;构造元组的例子被称为元组打包（tuple packing），对应的，其逆操作被称为元组解包（sequence unpacking），下面是元组解包的例子： 1234t = 12345, 54321, 'hello!'x, y, z = tprint x,y,z&gt;&gt;&gt; 12345 54321 hello! 注意：解包时需要左侧的变量列表具有与序列长度相同的元素数量，否则将引发异常（ValueError: too many values to unpack或ValueError: need more than [num] values to unpack）。 5.4 集合Set集合Set类型是由不重复元素组成的无序的集，基本用法包括成员查找和消除重复元素。 集合对象也支持并集（union），交集（intersection），差集（difference）和对称差分（symmetric difference）等数学运算。 构造集合可以使用set()函数或花括号，集合在创建时会自动清除重复元素： 12345678910#使用set()函数basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']fruit = set(basket)print fruit&gt;&gt;&gt; set(['orange', 'pear', 'apple', 'banana'])#使用花括号bsk = &#123;'apple', 'orange', 'apple', 'pear', 'orange', 'banana'&#125;print bsk&gt;&gt;&gt; set(['orange', 'pear', 'apple', 'banana']) 注意：创建空集合只能使用set()函数 集合提供快速的成员检索： 1234print 'orange' in fruit&gt;&gt;&gt; Trueprint 'crabgrass' in fruit&gt;&gt;&gt; False 集合之间的运算： 12345678910111213141516171819202122a = set('abracadabra')b = set('alacazam')print a&gt;&gt;&gt;set(['a', 'r', 'b', 'c', 'd'])print b&gt;&gt;&gt;set(['a', 'c', 'z', 'm', 'l'])#并集：|print a | b&gt;&gt;&gt; set(['a', 'c', 'b', 'd', 'm', 'l', 'r', 'z'])#交集：&amp;print a &amp; b&gt;&gt;&gt; set(['a', 'c'])#差集：-print a - b&gt;&gt;&gt; set(['r', 'b', 'd'])#对称差分print a ^ b&gt;&gt;&gt; set(['b', 'd', 'm', 'l', 'r', 'z']) 类似于列表推导式，集合也支持集合推导式set comprehensions： 123a = &#123;x for x in 'abracadabra' if x not in 'abc'&#125;print a&gt;&gt;&gt; set(['r', 'd']) 5.5 字典Dictionary数据类型字典Dictionary以关键字keys为索引，关键字可以是任意不可变类型（immutable type），通常是字符串string或数字number。 如果一个元组只包含字符串、数字或元组，那么这个元组也可以作为关键字。但如果元组直接或间接包含了其他可变对象，那么它就不能用作关键字。 列表不能用作关键字。 构造字典可以使用花括号包含用逗号分隔的键值对（key: value pairs）： 123tel = &#123;'jack': 4098, 'sape': 4139&#125;print tel&gt;&gt;&gt; &#123;'sape': 4139, 'jack': 4098&#125; 使用新的关键字并赋值，会为字典添加新的键值对； 使用已存在的关键字进行赋值，会修改字典中已存在的键值对： 1234567tel['guido'] = 4127print tel&gt;&gt;&gt; &#123;'sape': 4139, 'jack': 4098, 'guido': 4127&#125;tel['sape'] = 6666print tel&gt;&gt;&gt; &#123;'sape': 6666, 'jack': 4098, 'guido': 4127&#125; keys()方法返回字典中所有关键字组成的列表； del()方法删除字典中已存在的键值对： 12345print tel.keys()&gt;&gt;&gt; ['sape', 'jack', 'guido']del tel['sape']print tel&gt;&gt;&gt; &#123;'jack': 4098, 'guido': 4127&#125; 使用in来判断某个关键字是否存在于字典中： 1234print 'guido' in tel&gt;&gt;&gt; Trueprint 'boys' in tel&gt;&gt;&gt; False dict()构造函数可以直接使用键值对Sequence来创建字典： 123telp = dict([('sape', 4139), ('guido', 4127), ('jack', 4098)])print telp&gt;&gt;&gt; 'sape': 4139, 'jack': 4098, 'guido': 4127&#125; 字典同样支持字典推导式（dictionary comprehensions）： 12print &#123;x: x**2 for x in (2, 4, 6)&#125;&gt;&gt;&gt; &#123;2: 4, 4: 16, 6: 36&#125; 当关键字是简单字符串（simple strings）时，可以使用关键字参数来指定键值对，有时这将更加方便： 12print dict(sape=4139, guido=4127, jack=4098)&gt;&gt;&gt; &#123;'sape': 4139, 'jack': 4098, 'guido': 4127&#125; 5.6 循环的技巧当在Sequence中循环时，可以使用enumerate()函数将index和value同时取出： 12345for i, v in enumerate(['tic', 'tac', 'toe']): print i, v&gt;&gt;&gt; 0 tic&gt;&gt;&gt; 1 tac&gt;&gt;&gt; 2 toe 当同时在两个或更多Sequence中循环时，可以用zip()函数将其内元素一一匹配： 1234567questions = ['name', 'quest', 'favorite color']answers = ['lancelot', 'the holy grail', 'blue']for q, a in zip(questions, answers): print 'What is your &#123;0&#125;? It is &#123;1&#125;.'.format(q, a)&gt;&gt;&gt; What is your name? It is lancelot.&gt;&gt;&gt; What is your quest? It is the holy grail.&gt;&gt;&gt; What is your favorite color? It is blue. 如果要逆向循环一个Sequence，可以先正向定位它，然后调用reversed() 函数： 1234567for i in reversed(xrange(1, 10, 2)): print i&gt;&gt;&gt; 9&gt;&gt;&gt; 7&gt;&gt;&gt; 5&gt;&gt;&gt; 3&gt;&gt;&gt; 1 如果要按某个指定顺序循环一个Sequence，可以用 sorted()函数，它可以在不改动原序列的基础上返回一个排好序的新序列： 1234567basket = ['apple', 'orange', 'apple', 'pear', 'orange', 'banana']for f in sorted(set(basket)): print f&gt;&gt;&gt; apple&gt;&gt;&gt; banana&gt;&gt;&gt; orange&gt;&gt;&gt; pear 当在检索Dictionary时，可以使用iteritems()函数同时获取key和value： 12345knights = &#123;'gallahad': 'the pure', 'robin': 'the brave'&#125;for k, v in knights.iteritems(): print k, v&gt;&gt;&gt; gallahad the pure&gt;&gt;&gt; robin the brave 5.7 深入条件控制 优先级 由高到低：数值运算符 –&gt; 比较操作符 –&gt; 布尔运算符 布尔运算符中优先级由高到低：not –&gt; and –&gt; or 短路运算符（short-circuit operators） 布尔运算符中的and 和or也被称为短路运算符，它们的参数从左至右解析，一旦可以确定结果，解析停止。 while 和 if 条件句中可以使用任意操作，而不仅仅是比较操作。 比较操作符 in 和 not in 校验一个值是否在（或不在）一个序列里。 操作符 is 和 is not 比较两个对象是不是同一个对象，这只跟像列表这样的可变对象有关。 Python中，赋值操作不能发生在表达式内部。 5.8 比较序列和其他类型序列对象（Sequence objects）可以与具有相同序列类型的其他对象进行比较。 比较使用lexicographical ordering：首先比较前两个item，如果它们不同，则决定比较的结果；如果它们相等，则比较后面的两个item，以此类推，直到其中一个序列遍历完成。 如果要比较的两个item本身是同一类型的序列，则递归地进行lexicographical comparison比较。 注意：比较不同类型的对象是合法的。结果是确定的，但是是任意的，类型按它们的名称排序。因此，一个列表总是小于一个字符串，一个字符串总是小于一个元组，等等。","categories":[],"tags":[{"name":"python","slug":"python","permalink":"https://flowermushroom.github.io/tags/python/"}]},{"title":"网易互娱面试准备（一）","slug":"网易互娱面试准备（一）","date":"2019-08-09T00:56:27.000Z","updated":"2019-08-09T04:30:16.707Z","comments":true,"path":"2019/08/09/网易互娱面试准备（一）/","link":"","permalink":"https://flowermushroom.github.io/2019/08/09/网易互娱面试准备（一）/","excerpt":"","text":"前言搜集网络上各类面试题，并记录答案（非标准答案）。 1. 多态，多态的实现，派生类虚表的布局是怎样的在面向对象语言中，接口的多种不同的实现方式即为多态。 C++中，实现多态有以下方法：虚函数，抽象类，覆盖，模板（重载和多态无关）。 基类：父类；派生类：子类。 实现多态三点：1.必须最少两个类，而且必须是继承2.必须函数是虚函数（同名，同参，同返回类型）3.通过基类的指针或引用来实现 一个类里边无论有多少个虚函数，虚表指针 __vfptr 只会有一个，占四个字节 虚表中有两部分内容：1、虚函数的地址；2、虚函数 虚函数的地址总是以0x00000000作为结束 下面从4种情况对虚表进行详细的理解： 1、在单继承没有覆盖的情况下，子类的虚表会紧跟父类的虚表（虚函数按照声明顺序放于表中）。 2、在单继承有覆盖的情况下，覆盖的子类会替代原先父类虚表的位置，其余的子类虚表会紧跟父类。 3、在多继承没有覆盖的情况下，子类的虚表会紧跟第一个父类的虚表，其他的父类虚表中不会出现子类的虚表。 4、在多继承有覆盖的情况下，覆盖的子类会替代所有父类同名虚函数在虚表中的位置，其余的子类虚表会紧跟第一个父类的虚表。 基类的指针和引用调动派生类的虚函数，并不是访问的是派生类的虚函数，而是访问基类中被派生类覆盖的虚函数。 所以访问的位置还是在基类中，并没有进入派生类，这也是多态的实质。 参考：多态的实现原理分析—-虚表","categories":[],"tags":[]},{"title":"PHP学习笔记（一）","slug":"PHP学习笔记（一）","date":"2019-07-27T02:14:00.000Z","updated":"2019-07-27T02:14:51.386Z","comments":true,"path":"2019/07/27/PHP学习笔记（一）/","link":"","permalink":"https://flowermushroom.github.io/2019/07/27/PHP学习笔记（一）/","excerpt":"","text":"一、PHP语法初步PHP是一种运行在服务端的脚本语言，可以嵌入到HTML中。 （1）PHP代码标记在PHP历史发展中，可以使用多种标记来区分PHP脚本。 【基本弃用】 ASP标记： 1&lt;% php代码 %&gt; 短标记： 1&lt;? php代码 ?&gt; 脚本标记： 123456789101112&lt;script language=&quot;php&quot;&gt; php代码 &lt;/script&gt;&lt;html&gt; &lt;body&gt; &lt;b&gt; &lt;script language=&quot;php&quot;&gt; //脚本标记 echo &apos;hello world&apos;; &lt;/script&gt; &lt;/b&gt; &lt;/body&gt;&lt;/html&gt; 【最常用】标准标记： 123456789101112&lt;?php php代码 ?&gt;&lt;html&gt; &lt;body&gt; &lt;b&gt; &lt;?php //脚本标记 echo 'hello world; ?&gt; &lt;/b&gt; &lt;/body&gt;&lt;/html&gt; （2）PHP注释1.行注释 一次注释一行 12//注释内容#注释内容 2.块注释 一次注释多行 123/*注释内容*/ （3）PHP语句分隔符语句分隔符：在PHP中，代码以行为单位，系统通过分号 ; 来判断行的结束。 12$a = 5;echo 'hello world'; 特殊说明： php中标记结束符 ?&gt; 有自带语句结束符的效果，最后一行php代码可以没有语句结束符 ; 。【不建议使用】 php中很多代码的书写并不是嵌入到HTML中，而是单独存在，通常书写习惯中不建议使用 ?&gt; ，php会自动从开始到最后全部认为是php代码，从而解析。 二、变量php是一种动态网站开发的脚本语言，动态语言特点是交互性，会有数据的传递，而php作为”中间人”，需要进行数据的传递，传递的前提就是php自己能存储（临时）数据。 （1）变量的使用PHP中的所有变量都必须使用 $ 符号。 1.定义：在系统中增加对应的变量名字。（内存） 12&lt;?php $var1; //定义变量 2.赋值：可以将数据赋值给变量名。 12&lt;?php $var2 = 1; //定义同时赋值 3.可以通过变量名访问存储的数据 123456&lt;?php $var2 = 1; echo $var2; //通过var2变量名字找到存储的内容1，然后输出 $var2 = 2; //修改变量 echo '&lt;hr/&gt;', $var2; 4.可以将变量从内存中删除 1234&lt;?php //删除变量，使用unset(变量名) $var2 = 1; unset($var2); （2）变量命名规则 在PHP中变量名字必须以 “$” 符号开始。 名字由字母，数字和下划线构成，但不能以数字开头。 PHP本身中允许中文变量。【不推荐】 （3）预定义变量提前定义的变量，系统定义的变量，存储许多需要用到的数据。 这些预定义变量都是数组。 123456789$_GET; //获取所有表单以GET方式提交的数据$_POST; //POST提交的数据都会保存在此$_REQUEST; //GET和POST提交的数据都会保存在此$GLOBALS; //PHP中所有的全局变量$_SERVER; //服务器信息$_SESSION; //session会话数据$_COOKIE; //cookie会话数据$_ENV; //环境信息$_FILES; //用户上传的文件信息 （4）可变变量如果一个变量保存的值，刚好的是另外一个变量的名字，那么可以直接通过访问一个变量得到另外一个变量的值。 语法：在变量前面再多加一个 $ 符号。 123456&lt;?php //定义两个变量 $a = 'b'; $b = 'bb'; echo $$a; //输出'bb' 过程： 1.找到 $a ，解析结果：’b’ 2.将前面的 $ 与结果 ‘b’ 绑定，得到：$b 3.解析 $b （5）变量传值将一个变量赋值给另外一个变量。 1.值传递 将变量保存的值复制一份，然后将新的值给另外一个变量保存。【两个变量没有关系】 123456&lt;?php $a = 1; $b = $a; //值传递 $b = 2; echo $a,$b; //1,2 2.引用传递 将变量保存的值所在的内存地址，传递给另外一个变量，两个变量指向同一块内存空间。【两个变量是同一个值】 123456&lt;?php $a = 1; $b = &amp;$a; //引用传递 $b = 2; echo $a,$b; //2,2 12345在内存中，通常有以下几个分区：栈区：程序可以操作的内存部分，不存储数据，运行程序代码，小但快速。代码段：存储程序的内存部分，存储但不执行。数据段：存储普通数据，包括全局区和静态区。堆区：存储复杂数据的部分，大但效率低。 三、常量（1）基本概念常量：const/constant，是一种在程序运行当中，不可改变的量（数据）。 常量一旦定义，通常数据不可改变（用户级别）。 （2）常量定义形式1.使用定义常量的函数：define(‘常量名’, 常量值) 12&lt;?php define('PI', 3.14); define()函数定义的常量默认不区分大小写，可以改变函数参数以区分大小写。 2.const 常量名 = 值; 【此方法php5.3之后出现】 12&lt;?php const PI = 3.14; 3. define() 和 const 两种方式定义的常量，有访问权限上的区别。 （3）常量命名规则 常量不需要使用特殊符号 “$”。 常量的名字由字母、数字和下划线组成，不能以数字开头。 常量名字通常以大写字母为主（与变量区别）。 常量命名规则比变量松散，可以使用一些特殊字符。【这种常量只能用define()定义】拥有特殊字符的常量需要用函数 constant(‘常量名’) 来访问。 （4）系统常量系统帮主用户定义的常量，用户可以直接使用。 123PHP_VERSION：PHP版本号PHP_INT_SIZE：整型所占用的字节数PHP_INT_MAX：整型能表示的最大值 系统魔术常量：双下划线+常量名+双下划线，魔术常量的值会跟随环境变化，但用户不能改变。 123456__DIR__ :当前被执行的脚本所在电脑的绝对路径__FILE__ :当前被执行的脚本所在电脑的绝对路径，包括自己文件的名字__LINE__ :当前所属的行数__NAMESPACE__ :当前所属的命名空间__CLASS__ :当前所属的类__METHOD__ :当前所属的方法 四、数据类型因为php是一种弱类型语言，php变量本身没有数据类型，数据类型data type在php中指的是存储的数据本身的类型。 （1）php中的八种数据类型三大类： 1.简单（基本）数据类型：4小类整型：int/integer，4字节，表示整数类型。 浮点型：float/double，8字节，表示小数或整型存不下的整数。 字符串型：string，系统根据实际长度分配空间，表示字符串（引号）。 布尔类型：bool/boolean，表示布尔类型，只有两个值：true和false。 2.复合数据类型：2小类对象类型：object，存放对象（OO）。 数组类型：array，存储多个数据（一次性）。 3.特殊数据类型：2小类资源类型：resouce，存放资源数据（php外部数据，如数据库、文件）。 空类型：NULL，只有一个值NULL，不能运算。 （2）类型转换在很多情况下，需要将外部数据（当前php取得的数据）转换成目标数据类型。 1.自动转换：系统根据需求自己判定，自己转换。使用多，效率偏低。 2.强制转换：人为根据需要的目标类型转换。 1(目标类型)$变量 在转换过程中使用较多的：转布尔类型（判断）和转数值类型（算术运算）。 其他类型转bool：true和false。 其他类型转数值： 123456789101112131415/*1.bool转数值：true为1，false为0。2.字符串转数值： 2.1 以字母开头的字符串，永远为0。 2.2 以数字开头的字符串，取碰到字符串为止的数字，不会同时包含两个小数点。*/&lt;?php //创建数据 $a = 'abc1.1.1'; $b = '1.1.1abc'; //自动转换 1.1 echo $a + $b; //强制转换 0 1.1 echo '&lt;br/&gt;',(float)$a,(float)$b; （3）类型判断1.is_数据类型($变量名)通过一组类型判断函数，来判断变量，最终返回这个变量所保存数据的数据类型与函数类型是否相同，相同返回 true ，不同返回 false 。 是一组以 is_ 开头，后面跟类型名字的函数： 1is_数据类型($变量名) Bool类型不能用echo来查看，可以使用 var_dump(变量1, 变量2, …) 来查看。 1234567&lt;?php //创建数据 $a = 'abc1.1.1'; $b = '1.1.1abc'; var_dump(is_int($a)); //bool(false) var_dump(is_string($a)); //bool(true) 2.gettype($变量名)用来获取数据（变量）的类型。 获取类型，得到的是该类型对应的字符串。 3.bool settype($变量名, 类型)用来设定数据（变量）的类型。 设定数据类型，与强制转换不同， settype() 会直接改变存储的数据本身。 返回值bool为设定类型是否成功。 （4）整数、浮点、布尔1.整数类型保存整数数值（范围限制），4Bytes存储数据，最大32bits。 php中整型默认为有符号类型。 定义方式： 123456789101112&lt;?php #十进制定义 $a1 = 120; #二进制定义 0b+二进制数值 $a2 = 0b110; #八进制定义 0+八进制数值 $a8 = 0120; #十六进制定义 0x+十六进制数值 $a16 = 0x120; 2.浮点类型浮点型：小数类型以及超过整型存储范围的整数（不保证精度）。 精度范围：大概在15个有效数字左右。 定义方式： 1234&lt;?php $f1 = 1.23; $f2 = 1.23e10; //科学计数法 $f3 = PHP_INT_MAX + 1 //整型超过自身存储大小后会变为浮点型存储 浮点数保存的数据不够精确，尽量不用浮点数进行精确判断。 12345&lt;?php $f4 = 0.7; $f5 = 2.1; $f6 = $f5 / 3; var_dump($f4 == $f6); //bool(false) 3.布尔类型两个值：true 和 false。 通常用于判断比较。 empty()：判断数据的值是否为”空”（不是NULL），如果为”空”返回 true 。 isset()：判断数据的值是否存在，存在返回 true 。 五、运算符operator （1）赋值运算符赋值运算：”=”，将右边的结果（可以是变量、数据、常量、其他运算出来的结果）保存到内存的某一个位置，将这个位置的内存地址赋值给左侧的变量（常量）。 （2）算术运算符算术运算：基本的算术操作。 12345+：加-：减*：乘/：除%：取余（模运算） （3）比较运算符比较运算：比较两个数据的大小或是否相同。 12345678&gt;：大于&gt;=：大于等于&lt;：小于&lt;=：小于等于==：等于（大小相同）!=：不等于（大小不同）===：全等于（大小以及数据类型完全相同）!==：不全等于（大小或类型不同） 等于和全等例子： 123456&lt;?php $a = '123'; $b = 123; var_dump($a == $b); //bool(true) Var_dump($a === $b); //bool(false) （4）逻辑运算符逻辑运算：针对不同的结果进行匹配。 123&amp;&amp;：逻辑与，两边条件同时成立返回 true 。||：逻辑或，两边条件只要有一个成立返回 true 。!：逻辑非，对已有条件取反。 &amp;&amp; 和 || 又称为短路运算，如果第一个表达式结果已经可以得出返回值，那么就不会运行逻辑运算符后面的表达式。 （5）连接运算符连接运算：php中将多个字符串拼接的一种符号。 12.：将两个字符串连接到一起.=：符合运算，将左面的内容与右边的内容连接起来，然后重新赋值给左边变量。 （6）错误抑制符php中有一些错误可以提前预知，但可能无法避免，这时可以使用错误抑制符处理。 1@：在可能出错的表达式前面使用@符号 例子： 1234&lt;?php $a = 10; $b = 0; @($a % $b); //不会报错 错误抑制符通常在生产环境（上线）用到，在开发时不会使用。 （7）三目运算符三目运算符：有三个表达式参与的运算，是简单的分支结构的缩写。 1表达式1 ? 表达式2 : 表达式3; 如果表达式1成立，那么执行表达式2，否则执行表达式3。 （8）自操作运算符自操作：自己操作自己的运算符。 12++：在原值上加1--：在原值上-1 （9）位运算符位运算：取出计算机中最小的单位（bit）进行运算。 123456$：按位与，两个位都为1，结果位1，否则为0|：按位或，两个有一个为1，结果为1~：按位非，如果为1，则变成0，否则反之^：按位异或，两个相同则为0，不同则为1&lt;&lt;：按位左移，整个二进制数向左移动一定位数，右边补0，相当于乘以2操作&gt;&gt;：按位右移，整个二进制数向右移动一定位数，左边补符号位对应值（正数补0，负数补1），相当于除以2操作 注意： 1.系统进行任何位运算时，使用的都是补码 2.运算结束后都必须转换成原码才是最终要显示的数据 六、流程控制流程控制：代码执行的方向 （1）控制分类顺序结构：代码从上向下顺序执行，代码执行的最基本结构 分支结构：给定一个条件，同时有多种可执行代码（块），然后会根据条件执行某一段代码 循环结构：在某个条件控制范围内，指定的代码（块）可以重复执行 （2）分支结构1.if分支12345678910111213141516171819202122232425//最简ifif(条件表达式)&#123; //满足条件所要执行的代码&#125;//基础ifif(条件表达式)&#123; //满足条件所要执行的代码&#125;else&#123; //不满足条件所要执行的代码 &#125;//复杂ifif(条件表达式1)&#123; //满足条件1所要执行的代码&#125;elseif(条件表达式2)&#123; //满足条件2所要执行的代码&#125;elseif(条件表达式...)&#123; //可以使用多个elseif来进行条件筛选&#125;else&#123; //所有条件全部不满足所要执行的代码&#125; 2.swich分支1234567891011121314switch(条件表达式)&#123; //所有条件判断：逐个执行 case 值1: //当前表达式的结果与值1相等 //要执行的代码段 break; //中断swich case 值2: //当前表达式的结果与值1相等 //要执行的代码段 break; //中断swich //...设置任意数量匹配值 default: //匹配失败的代码&#125; （3）循环结构1.for循环123456789/* 条件表达式1：定义初始化条件 条件表达式2：边界判定，限定循环执行次数 条件表达式3：用来执行条件变化*/for(条件表达式1; 条件表达式2; 条件表达式3)&#123; //循环体&#125; 2.while循环1234567/* 条件表达式判断边界条件 条件变化在循环体中实现*/while(条件表达式)&#123; //循环体&#125; 3.do-while循环123do&#123; //循环体&#125;while(条件表达式); 4.循环控制中断控制：continue; 结束本次循环，重新开始循环. ​ continue n;对n层嵌套的循环同时执行结束本次循环的操作 终止控制：break; 整个循环结束. ​ break n;对n层嵌套的循环同时执行终止整个循环的操作 5.流程控制（替代语法）：九九乘法表： 1234567891011&lt;table border=1&gt; &lt;?php for($i = 1; $i &lt; 10; $i++)&#123;?&gt; &lt;tr&gt; &lt;?php for($j = 1; $j &lt;= $i; $j++)&#123;?&gt; &lt;td&gt; &lt;?php echo $i . &quot; * &quot; . $j . &quot; = &quot; . $i*$j;?0&gt; &lt;/td&gt; &lt;?php &#125;?&gt; &lt;/tr&gt; &lt;?php &#125;?&gt;&lt;/table&gt; 使用 for(;;): endfor; ** 替代 **for(;;){ } 1234567891011&lt;table border=1&gt; &lt;?php for($i = 1; $i &lt; 10; $i++):?&gt; &lt;tr&gt; &lt;?php for($j = 1; $j &lt;= $i; $j++):?&gt; &lt;td&gt; &lt;?php echo $i . &quot; * &quot; . $j . &quot; = &quot; . $i*$j;?0&gt; &lt;/td&gt; &lt;?php endfor?&gt; &lt;/tr&gt; &lt;?php endfor;?&gt;&lt;/table&gt; 替代语法： 12345if： if(): endif;switch： switch(): endswitch;forwhileforeach 七、文件包含文件包含四种形式：include, require, include_once, require_once （1）文件加载原理 在文件加载（include或者require）的时候，系统会自动的将包含文件的代码相当于嵌入到当前文件中 加载位置：在哪加载，对应的文件中代码嵌入的位置就是对应的include位置 在PHP中被包含的文件是单独进行编译的 PHP文件在编译过程中如果出现了语法错误，那么会失败（不会执行）；但是如果被包含的文件有错误时，系统会执行到包含include这条语句的时候才会报错。 （2）include和include_once的区别：include ：系统碰到一次，执行一次，如果对同一个文件进行多次加载，那么系统会执行多次； include_once ：系统碰到多次，也只会执行一次。 （3）require和include的区别本质都是包含文件，唯一的区别在于包含不到文件的时候，报错的形式不一样。 include的错误级别较轻（Warning），不会阻止代码执行。 require的错误级别较高（Fatal Error），如果包含出错，require后面的代码不会执行。 （4）文件加载路径文件在加载的时候需要指定文件路径才能保证PHP正确的找到对应的文件。 1.绝对路径本地绝对路径：从磁盘的根目录开始 ​ Windows：盘符c:/路径/PHP文件 网络绝对路径：从网站根目录开始 ​ / : 相对于网站主机名字对应的路径 ​ localhost/index.php —&gt; D:/Server/Apache24/htdocs/PHPBasic/index.php 2.相对路径从当前文件所在目录开始的路径 . 或 ./ ： . 表示当前文件夹 ../ ：上级目录（当前文件夹的上一层文件夹） 3.绝对路径与相对路径的加载区别绝对路径相对效率偏低，但是相对安全（路径不会出问题）。 相对路径相对效率高些，但是容易出错（相对路径会发生改变）。 （5）文件嵌套包含文件嵌套包含：一个文件包含另一个文件，同时被包含的文件又包含了另外一个文件。 嵌套包含时容易出现相对路径错误，相对路径（ ./ 和 ../ ）会因为文件的包含而改变。 八、函数function：一种语法结构，将实现某一个功能的代码块（多行代码）封装到一个结构中，从而实现代码的重复利用。 （1）函数语法1.函数的定义： 1234function 函数名(参数1,...)&#123; //函数体 return 结果; //返回值&#125; 2.函数的调用：函数的调用可以在函数定义之前 1函数名(参数1,...); 3.命名规范： ​ 由字母、数字和下划线组成，但不能以数字开头。 ​ 在一个脚本周期中，不允许出现同名函数。（通常在一个系统开发中都不会使用同名函数） （2）参数详解1.实参与形参1.形参：形式参数，不具有实际意义，在函数定义时使用的参数 2.实参：实际参数，具有实际数据的参数，实在函数调用时使用的参数，形参是实参的载体 注意： 1.php中允许实参个数多于形参，但不能少于形参。 2.理论上形参个数没有限制。 2.参数默认值：default value，指的是形参的默认值，在函数定义的时候，就给形参进行一个初始赋值。如果没有提供实际调用传入的参数（实参），那么形参就会使用定义时的值来进入函数内部参与运算。 123function add($num1 = 0, $num2 = 0)&#123; echo $num1 + $num2;&#125; 注意： 默认值的定义是放在最后面的参数上的，不能左边的形参有默认值而右边的形参没有默认值。 3.值传递与引用传递值传递：将实参（变量或其他表达式）的结果（值）取出来赋值给形参，形参与外部实际传入的参数本身没有任何关联。 引用传递：在函数定义时，说明希望能够在函数内部改变函数外部的数据，这样函数调用时会主动获取外部数据的内存地址，直接操作外部数据。 123function 函数名($值传递形参名, &amp;$引用传递形参名)&#123; //函数体&#125; 注意：函数调用时，引用传递的形参必须传入变量实参。 （3）函数体函数体：函数内部（大括号里面）的所有代码。 （4）函数返回值php中所有的函数都有返回值，默认返回值为NULL。 函数的返回值可以是任意类型。 return关键字： 1.return在函数内部使用：返回当前函数的结果，当前函数运行结束，return后的代码不会被执行。 2.return在文件中直接使用（不在函数里面）：文件将return后面的内容（代码语句），转交给包含当前文件的位置，同时终止return后面的代码（return之后的内容不会执行），通常在系统配置文件中使用较多。 （5）作用域作用域：变量（常量）能够被访问的区域。 1.变量可以在普通代码中定义 2.变量也可以在函数内部定义 在php中，作用域（严格来说）分为两种，但php内部还定义了一种严格意义之外的作用域： 1.全局变量：用户普通定义的变量 ​ 所属全局空间，在php中只允许在全局空间使用，理论上在函数内部不可访问。 ​ 脚本周期：直到脚本运行结束，最后一行代码执行完。 2.局部变量：在函数内部定义的变量 ​ 所属当前函数空间，在php中只允许当前函数自己使用。 ​ 函数周期：函数执行结束，函数在栈区中开辟独立内存空间运行。 3.超全局变量：系统定义的变量（如预定义变量$_SERVER等） ​ 所属超全局空间，没有访问限制，函数内外都可以访问。 ​ 超全局变量会将全局变量自动纳入到$GLOBALS数组里面，而$GLOBALS没有作用域限制，所以能够帮助在局部空间中访问全局变量：但是必须使用数组方式。 123456$global = 'global area'; //最终会被系统纳入到超全局变量中，$GLOBALS['global'] = 'global area'function display()&#123; var_dunp($GLOBALS); //查看数组内容 echo $GLOBALS['global']; //用下标global访问数组内容 &#125; 在php中，还有一种实现变量跨域访问的方式：global关键字 global关键字：是一种在函数里面定义变量的一种方式 1.如果使用global定义的变量名在外部存在（全局变量中已经存在），那么在函数内部定义的变量将指向外部已经定义的全局变量所指向的内存空间（同一个变量）。 2.如果使用global定义的变量名在外部不存在，系统会自动在全局空间定义一个与此变量同名的全局变量。 本质的形式：在函数的内部和外部，对一个同名变量使用同一块内存地址保存数据。 12global 变量名; //定义时不能赋值变量名 = 值; 使用global关键字跨域访问： 12345678910111213$global = 'global area';function display1()&#123; global $global; //对于全局空间存在的变量 echo $global; //打印 global area&#125;function display2()&#123; global $local; //对于全局空间不存在的变量 $local = 'inner'; &#125;echo $local; //打印 inner （6）静态变量静态变量：使用static关键字，用来实现跨函数共享数据的变量，即同一个函数被多次调用时，共享同一个变量同一个数据。 123function 函数名()&#123; static $变量名 = 变量值&#125; 例子： 123456789function display()&#123; $local = 1; //局部变量 static $count = 1; //静态变量 echo $local++, ' ', $count++, '&lt;br/&gt;';&#125;display(); //1 1display(); //1 2display(); //1 3 原理：系统在编译php文件的时候，就会对static变量进行初始化，函数在调用的时候，static变量定义的过程会被跳过。 静态变量的使用： 1.统计当前函数被调用的次数 2.统计函数被多次调用得到的不同结果（递归思想） （7）可变函数可变函数：当前有一个变量所保存的值，刚好是一个函数的名字，那么就可以使用 变量+() 来充当函数名使用。 12345$func = 'display';function display()&#123;&#125;$func(); //等同于 display(); 可变函数的使用：系统函数需要用户在外部定义定义一个自定义函数，但是需要传入到系统函数内部使用。 12345678910111213//定义系统函数（假设）function sys_function($arg1, $arg2)&#123; //给指定的函数（第一个参数），求对应第二个参数值的四次方 //为实际用户输入的数值进行处理 $arg2 = $arg2 + 10; return $arg1($arg2);&#125;//定义一个用户函数：求一个数的四次方function user_function($num)&#123; return $num * $num * $num * $num;&#125;//求10+10的4次方echo sys_function('user_function', 10); （8）匿名函数匿名函数：没有名字的函数 定义与调用： 12345$变量名 = function()&#123; //函数体&#125;;//调用匿名函数$变量名(); 变量保存匿名函数，本质上得到的是一个对象（Closure类）。 闭包：closure，函数内部有一些局部变量（要执行的代码块）在函数执行之后没有被释放，是因为在函数内部还有对应的函数在引用这些局部变量（函数内部的函数：匿名函数）。 1234567891011121314151617181920//闭包函数function display()&#123; //定义变量：局部变量 $name = __FUNCTION__; //定义匿名函数 //use就是将外部变量（局部变量）保留给内部使用（闭包） $innerfunc = function() use($name)&#123; //函数内部的函数 //匿名函数调用了局部变量$name echo $name; &#125;; //返回内部匿名函数 return $innerfunc;&#125;$closure = display();//display()函数运行结束，但局部变量$name没有被释放,从而在外部调用内部匿名函数的时候可以被使用$closure(); （9）伪类型伪类型：实际上在php中不存在的类型，但是通过伪类型可以帮助程序员更好地查看操作手册，方便学习。 伪类型主要有两种（在八小类类型之外）： 1.mixed：混合的，可以是多种php中的数据类型 2.number：数值的，可以是任意数值类型（整型和浮点型） （10）常用系统函数3.常用数学函数 12345678910max()：指定参数中的最大值min()：指定参数中的最小值rand()：得到一个指定区间的随机整数mt_rand()：与rand一样，只是底层结构不一样，效率比rand高round()：四舍五入cell()：向上取整floor()：向下取整pow()：幂运算abs()：绝对值sqrt()：平方根 4.有关函数的函数 1234function_exist()：判断指定的函数名字是否在内存中存在func_get_arg()：在自定义函数中获取指定index对应的参数func_get_args()：在自定义函数中获取所有的参数（数组）func_num_args()：在自定义函数中获取函数的参数数量 注意：func_get_args()和func_num_args()统计的都是实参而非形参 九、错误处理错误处理：指的是系统（或者用户）在对某些代码进行执行的时候，发现有错误，就会通过错误处理的形式告知程序员。 （1）错误分类1.语法错误：用户书写的代码不符合php语法规范，语法错误会导致代码在编译过程中不通过，所以代码不会执行(parse error)。 2.运行时错误：代码编译通过，但是代码在执行过程中会出现一些条件不满足导致的错误（runtime error）。 3.逻辑错误：程序员在写代码的时候不够规范，出现了一些逻辑性的错误，导致代码正常执行，但是得不到想要的结果。 （2）错误代号所有看到的错误代号在php中都被定义成了系统常量（可以直接使用）。 所有以 E 开头的错误常量（代号）其实都是由一个字节存储，然后每一种错误占据一个对应的位，错误控制因此可以使用位运算。 1.系统错误 1234E_PARSE：编译错误，代码不会执行E_ERROR：fatal error，致命错误，会导致代码不能正确继续执行（出错的位置断掉）。E_WARNING：warning，警告错误，不会影响代码执行，但是可能得到意想不到的结果。E_NOTICE：notice，通知错误，不会影响代码执行。 2.用户错误 用户在使用自定义错误触发的时候，会使用到的错误代号（系统不会用到）。 123E_USER_ERRORE_USER_WARNINGE_USER_NOTICE 3.其他 1E_ALL：代表着所有的错误（通常在进行错误控制时候使用），建议在开发过程中（开发环境）使用。 排除通知错误： 1E_ALL &amp; ~E_NOTICE （3）错误触发1.程序运行时触发 系统自动根据错误发生后，对比对应的错误信息，输出给用户。 主要针对代码的语法错误和运行时错误。 2.人为触发 知道某些逻辑可能会出错，从而使用对应的判断代码来触发相应的错误提示。Trigger_error(错误提示); 123456789101112&lt;?php //处理脚本，让浏览器按照指定字符集解析 header('Content-type:text/html;charset=utf-8'); $a = 100; $b = 0; if($b == 0)&#123; trigger_error('除数不能为0'); //默认notice错误，代码会继续执行 trigger_error('除数不能为0', E_USER_ERROR); //设置为error，代码终止执行 &#125; echo $a / $b; （4）错误设置1.错误显示设置哪些错误该显示，以及该如何显示。 php中，有两种方式来设置当前脚本的错误处理： ​ a.php的配置文件：全局配置 php.ini 文件 12error_reporting：显示什么级别的错误display_errors：是否显示错误 ​ b.在运行的php脚本中设置：在脚本中定义的配置项函数级别比配置文件高 12int error_reporting([int $level])：设置对应的错误显示级别ini_set('配置文件中的配置项', 配置值)：ini_set('error_reporting', E_ALL); 2.错误日志设置在实际生产环境中，不会直接将错误展示给用户（不友好、不安全），一般不显示错误，而是将错误保存到日志文件中。 ​ a.在php配置文件中或者代码中，设置log_errors配置项，来开启日志功能。 ​ b.在php配置文件中或者代码中，设置error_log配置项来指定日志文件路径。 （5）自定义错误处理最简单的错误处理：trigger_errors()函数，该函数不会阻止系统报错。 php系统提供了一种用户处理错误的机制：用户自定义错误处理函数，然后将该函数增加到操作系统错误处理的句柄中，然后系统会在碰到错误之后，使用用户定义的错误函数。 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php //处理脚本，让浏览器按照指定字符集解析 header('Content-type:text/html;charset=utf-8'); //自定义函数 function my_error($errno, $errstr, $errfile, $errline)&#123; //判断当前会碰到的错误有哪些 //error_reporting()获取当前系统错误处理对应的级别 if(!(error_reporting() &amp; $errno))&#123; return false; &#125; //开始判断错误类型 switch($errno)&#123; case E_ERROR; case E_USER_ERROR; echo 'fatal error in file ' . $errfile . ' on line ' . $errline . '&lt;/br&gt;'; echo 'error info : ' . $errstr; break; case E_WARNING; case E_USER_WARNING; echo 'warning in file ' . $errfile . ' on line ' . $errline . '&lt;/br&gt;'; echo 'error info : ' . $errstr; break; case E_NOTICE; case E_USER_NOTICE; echo 'notice in file ' . $errfile . ' on line ' . $errline . '&lt;/br&gt;'; echo 'error info : ' . $errstr; break; &#125; return true; &#125; //报错 echo $a; //修改错误机制 set_error_handler('my_error'); //报错 echo $a; 十、字符串类型（1）字符串定义语法 引号方式定义 1.单引号字符串 1$str1 = 'hello'; 2.双引号字符串 1$str2 = \"hello\"; 引号方式：比较适合定义比较短、没有结构要求的字符串 双引号区别于单引号，能识别变量（用此方法识别变量需要保证变量独立性，如：使用变量标识符 {$a} ）和更多的转义字符。 结构化方式定义 3.nowdoc字符串：没有单引号的单引号字符串 语法： 123$变量名 = &lt;&lt;&lt;'边界符' 字符串内容边界符; 例子： 1234$str3 = &lt;&lt;&lt;'EOD' hello worldEOD; 4.heredoc字符串：没有双引号的双引号字符串 语法： 123$变量名 = &lt;&lt;&lt;边界符 字符串内容边界符; 例子： 1234$str4 = &lt;&lt;&lt;EOD hello worldEOD; （2）字符串转义转义：在计算机统用协议中，有一些特定的方式定义的字母，系统会特定处理，通常使用反斜杠+字母的特性 \\r\\n：回车换行 php中常用的转义符号： 12345678910\\'：在单引号字符串中显示单引号\\\"：在双引号字符串中显示双引号\\r：回车（理论上回到当前行的首位置）\\n：代表新一行\\t：类似Tab键，输出4个空格\\$：在php中，$为变量符号，需要在字符串中特殊识别以上单引号字符串只能够识别：\\'双引号字符串只不能识别：\\' （3）字符串长度1.基本函数 strlen()：得到字符串的长度，以字节为单位 ​ 注意：每个汉字在utf-8字符集下占3个字节 2.多字节字符串扩展模块：mbstring 扩展（mb为Multi Bytes） ​ 加载扩展：php.ini 中 extension=php_mbstring.dll 语句取消注释 ​ 使用mb扩展带来的函数：mb_strlen($字符串变量, ‘字符集’) ​ 在 utf-8 字符集中，mb_strlen()对汉字求长度，一个汉字+1 （4）字符串相关函数1.转换函数 123implode()：将数组中的元素按照某个规则连接成一个字符串explode()：将字符串按照某种格式进行分割，变成数组str_split()：按照指定长度拆分字符串返回数组 2.截取函数 12345trim()：默认用来去除字符串首尾的空格，也可以指定要去除的首尾的内容ltrim()：去除字符串首内容rtrim()：去除字符串尾内容substr()：指定位置索引位置开始截取字符串，可以指定长度，不指定长度就截取到字符串尾strstr()：从指定字符串位置开始截取字符串到最后 3.大小写转换 123strtolower()：全部小写strtoupper()：全部大写ucfirst()：首字母大写 4.查找函数 12strpos()：判断字符在目标字符串中首次出现的位置，用===判断是否出现strrpos()：判断字符在目标字符串中最后出现的位置 5.替换函数 12str_replace()：将目标字符串中部分字符串进行替换str_replace('匹配目标', '替换内容', 字符串) 6.格式化函数 1printf()/sprintf() 7.其他函数 12str_repeat()：重复某个字符串N次str_shuffle()：随机打乱字符串（验证码） 十一、数组 array（1）数组定义语法1.使用 array 关键字（最常用） 1$变量 = array(元素1, key =&gt; value , ...); 2.使用中括号来包裹数据 1$变量 = [元素1, 元素2, ...]; 3.隐形定义数组：给变量加一个中括号，系统自动变成数组 12$变量[] = 值; //默认下标为当前最大下标+1$变量[下标] = 值; （2）数组特点1.可以使用整数下标或者字符串下标 ​ 索引数组：数组下标都为整数 ​ 关联数组：数组下标都为字符串 ​ 混合数组：整数下标和字符串下标混合存在 2.数组元素的顺序以放入顺序为准，与下标无关 3.特殊值下标的自动转换 ​ 布尔值：true –&gt; 1 , false –&gt; 0 ​ 空：NULL –&gt; “” （3）多维数组数组里面的元素又是数组 1.二维数组：数组中所有的元素都是一维数组 1234567$info = array( array('name' =&gt; 'Jim', 'age' =&gt; 30), array('name' =&gt; 'Tom', 'age' =&gt; 28), array('name' =&gt; 'Lily', 'age' =&gt; 20));echo '&lt;pre&gt;';print_r($info); 2.多维数组 二维数组的数组元素中可以继续是数组，php中没有维度限制（本质上没有二维数组的定义），不建议使用三维以上的数组，会再增加访问的复杂度，降低访问效率 3.异形数组（不规则数组） 数组中的元素不规则，有数组也有普通基本变量 在实际开发中并不常用，尽量让数组元素规则化，便于访问 （4）数组遍历1.foreach 遍历1234foreach($数组变量 as [$下标 =&gt;] $值)&#123; //通过$下标访问元素的下标 //通过$值来访问元素的值&#125; 如果是关联数组一般需要下标，如果是索引数组一般不需要下标。 例子： 123456789$arr = array(1,2,3,4,5,6,7,8,9,10);foreach($arr as $v)&#123; echo $v , '&lt;br/&gt;';&#125;foreach($arr as $k =&gt; $v)&#123; echo 'key:',$k,'==value: ',$v,'&lt;br/&gt;';&#125; foreach 遍历原理： 数组内部有一个指针，默认指向数组的第一个元素，foreach利用指针去获取数据，同时移动指针。 1.foreach重置指针，让指针指向第一个元素 2.进入foreach循环，通过指针取得当前第一个元素，将下标和值取出，放入对应的下标变量和值变量中 3.指针下移（+1） 4.进入循环体，执行代码 5.重复2 3 4，直到在第二步中指针取不到内容（指针指向数组最后） 2.for 循环遍历使用条件： 1.已知边界条件（起始、结束） 2.已知数组长度， count() 函数 3.要求数组元素下标是有条件(规律)的变化 12345$arr = array(1,2,3,4,5,6,7,8,9,10);for($i = 0, $len = count($arr);$i &lt; $len; $i++)&#123; echo 'key:',$i,'==value: ',$arr[$i],'&lt;br/&gt;';&#125; 3.while配合each和list遍历数组each函数： each能够从一个数组中获取当前数组指针所指向的元素的下标和值，拿到之后，将数组指针下移，同时将拿到的元素下标和值以一个4个元素的数组返回，此4个元素的数组： ​ 0下标 =&gt; 取得元素的下标值 ​ 1 下标 =&gt; 取得的元素 ​ key下标 =&gt; 取得元素的下标 ​ value下标 =&gt; 取得元素的值， 如果each取不到元素，返回false 123456789101112131415161718192021222324252627282930313233343536373839$arr = array(1,'name'=&gt; 'Tom',3,'age'=&gt;30); echo '&lt;pre&gt;'; print_r(each($arr)); print_r(each($arr)); print_r(each($arr)); print_r(each($arr)); var_dump(each($arr));/*结果：Array( [1] =&gt; 1 [value] =&gt; 1 [0] =&gt; 0 [key] =&gt; 0)Array( [1] =&gt; Tom [value] =&gt; Tom [0] =&gt; name [key] =&gt; name)Array( [1] =&gt; 3 [value] =&gt; 3 [0] =&gt; 1 [key] =&gt; 1)Array( [1] =&gt; 30 [value] =&gt; 30 [0] =&gt; age [key] =&gt; age)bool(false)*/ list结构： list是一种结构，不是一种函数（没有返回值），list提供一个或一组变量去从一个数组中取得元素值，然后依次存放到对应的变量中（相当于批量为变量赋值，值来源于数组）。 条件：list必须从索引数组中获取数据 123$arr = array(3,2 =&gt;1); list($first) = $arr; var_dump($first); //int(3) 错误使用：变量多于数组元素，没有指定从0到指定变量的下标的数组元素 1234567891011 $arr = array(3,2 =&gt;1); list($firs, $second) = $arr; var_dump($first, $second);/*Notice: Undefined offset: 1 in --\\arr.php on line --int(3) NULL$arr[1]不存在，$arr[2] == 1，$second变量对应下标为1的元素，list找不到下标为1的元素，故出错*/ list与each配合：each一定有两个元素就是0下标和1下标元素 123456789101112$arr = array(1,'name'=&gt; 'Tom',3,'age'=&gt;30);while(list($key,$value) = each($arr))&#123; echo 'key:', $key , '==value: ', $value , '&lt;br/&gt;';&#125;/*key:0==value: 1key:name==value: Tomkey:1==value: 3key:age==value: 30*/ （5）数组相关函数1.排序函数都是按照ASCII码进行比较 1234567sort()：顺序按元素值排序，从低到高，下标重排rsort()：逆序asort()：顺序按元素值排序，下标对应关系保留arsort()ksort()：顺序按键名（下标）排序，下标对应关系保留krsort()shuffle()：随机打乱数组元素，下标重排 以上函数返回值均为bool类型，执行后直接修改源数组 2.指针函数123456reset()：重置指针，将数组指针回到首位，返回元素值end()：重置指针，将数组指针指到最后一个元素，返回元素值next()：将数组中的内部指针+1，返回下一个元素的值prev()：将数组中的内部指针-1，返回上一个元素的值current()：获取当前指针对应的元素值key()：获取当前指针对应的键名（下标） 注意：如果使用next()或prev()导致指针移出数组，将无法再次使用next()和prev()使指针回到正确的位置，此时只能通过reset()或end()重置指针。 3.其他函数123456789101112count()：统计数组中元素的数量array_push()：在数组尾部加入一个元素array_pop()：从数组尾部取出一个元素array_unshift()：在数组开头加入一个元素array_shift()：从数组开头取出一个元素array_reverse()：将数组元素顺序翻转in_array()：判断一个元素在数组中是否存在array_keys()：获取一个数组的所有下标，返回一个索引数组array_values()：获取一个数组的所有值，返回一个索引数组","categories":[],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://flowermushroom.github.io/tags/PHP/"}]},{"title":"软件架构与设计模式学习笔记","slug":"软件架构与设计模式学习笔记","date":"2019-06-11T16:00:00.000Z","updated":"2019-07-27T08:12:03.452Z","comments":true,"path":"2019/06/12/软件架构与设计模式学习笔记/","link":"","permalink":"https://flowermushroom.github.io/2019/06/12/软件架构与设计模式学习笔记/","excerpt":"","text":"（一）课程简介&amp;概述 对于大型、复杂、软件密度高(software-intensive)的系统而言，系统的宏观结构设计成为系统成败的决定性关键因素。 一、什么是软件体系结构软件体系结构（Software Architecture）是： 解决日益复杂的软件系统的分析不设计问题 刻画大型复杂软件系统的静态结构与动态行为 构造更大更复杂软件系统的有效工程方法 的一种软件设计技术与软件工程方法。 一个软件系统的体系结构是指它所包含的计算构件和这些构件间的交互作用。 即：Software Architecture= SA = {components, connectors} Component（构件/组件）：系统的逻辑与功能结构组成单元。 Connector（连接件）：构件间相互交互的机制与规则。 二、各个时期的软件（1）软件的机器指令时代：这个时代的程序就是若干条机器指令所组成的一段顺序执行的计算指令，软件的结构表现为指令之间的顺序结构。 （2）软件的汇编与早期的高级语言时代：这个时代的软件的宏观结构体现为主-子程序的调用与被调用的结构。 （3）软件的面向结构时代：在面向结构的软件开发时代，模块的聚集和嵌套形成层层调用的软件宏观结构。人们在设计软件时，开始先从软件模块的抽象结构粒度上考虑软件系统的宏观结构。 （4）软件的面向对象时代：对于面向对象的软件系统，包（Package）或名字空间（Namespace）是对象的结构化组织，而系统的包结构或名字空间的划分来体现软件的一种宏观静态结构。 三、理解软件体系结构（1）宏观与微观系统体系结构设计（宏观）：体系结构模型 系统详细设计（微观）：详细设计模型 （2）自顶向下和自底向上对系统的设计过程：由总体到局部（Top-down） 系统实现的过程：先局部再整体（Bottom-up） （二）软件体系结构基础 一、软件体系结构的核心概念模型（1）Component（构件）Component（构件）：系统的逻辑与功能结构单元。 构件是一种抽象概念表述。是对以各种具体实现技术的系统结构组成元素（如子系统、模块、包等）的统称。 构件是对系统功能集中的一个功能子集的结构化封装与实现。每个构件对于系统而言，应具有一定功能性。 构件通过其端口（Port）与外部环境交互。构件的端口（Port）表示了构件和外部环境的交互作用点。 端口（Port）：构件与外界的交互作用点，是构件的外部可见特征（Visible Properties）。 构件的可分解性： 构件的可分解性： 原子（atom）构件：不再需要进行分解的构件。 复合（composite）构件：需要再进行分解的构件。 分类： 根据功能层次：基础构件、中层构件、高层构件。 根据复用度：通用构件、专用构件。 根据功能类别：数据构件、界面构件、控制构件、安全构件。 （2）Connector（连接件）Connector（连接件）：构件间相互交互的机制或规则。 机制：是指连接件的具体实现形式：如过程调用、共享存储区。 规则：是指构件使用连接件应遵循的规范。如对“过程调用”这种连接件其规则是指调用的接口参数形式、共享存储区则是指其本身的数据存储结构。 构件在交互过程中体现为不同的角色。 一个连接件所涉及的角色可能是二元的，也有多元的。 方向性：单向和双向。有返回值的函数调用为双向连接。 性能特性：同步/异步连接、开放/安全连接、串行/并行 … （3）Configuration（配置）Configuration（配置）：构件与连接件的装配规约（Assemble Specification）。 描述了构件通过连接件相互交互所形成的逻辑拓扑结构（Topology）。 定义了构件、连接件的使用规则与约束。 相同的构件集与连接件集，通过不同的配置可形成不同结构形态的软件体系结构： 构件的端口与连接件的角色之间的关联关系；复合构件与其子构件的嵌套包含关系。 二、软件体系结构分析设计的两种基本方法：（1）分解（Decomposition）按照系统功能分解的方式，将系统功能进行分解，每一个相对独立的功能分解模块形成系统结构的一个功能构件。 （2）组合（Composition）考虑系统的各功能构件间的相互关系，通过什么样的连接机制实现将各个独立的构件形成一个整体系统。 三、系统架构的多维度分解模型：业务域分解、功能域分解、技术域分解、涉众域分解。 架构分解过程模型：迭代的过程模型。 四、软件体系结构的评价（1）软件体系结构的功能特性软件体系结构的功能特性（Functional Property of the SA）：软件体系结构对软件需求规范中所定义的功能需求满足程度。 （2）软件体系结构的非功能特性软件体系结构的非功能特性（Non-functional Property of the SA）：软件体系结构对软件需求规范中所定义的非功能需求满足程度。 非功能特性体现了软件的质量，决定了一个软件系统的架构设计优劣。 分为：运行期的非功能特性、开发期的非功能特性。 运行期的非功能特性：性能、安全性、易用性、可用性、可伸缩性、互操作性、可靠性、健壮性。 开发期的非功能特性：易理解性、可扩展性、可重用性、可测试性、可维护性、可移植性。 （三）软件体系结构建模 一、体系结构的模型从不同的视角（view-point），可以刻画系统的体系结构不同侧面。 每一个不同视角的刻画均是对系统体系结构的一个描述，我们往往需要从不同视角来描述一个系统的体系结构。 二、“4+1”视图模型​ By: Philippe Kruchten (1995) 使用多个并发的视图来组织软件架构的描述，每一个视图只关心软件体系结构的一个侧面，5个视图结合在一起才能完整反映软件体系结构的全部内容。 （1）Logic View（逻辑视图）Logic View（逻辑视图）：基于功能需求抽象，刻画系统的静态结构模型。 视角：功能需求的分析理解与抽象； 关注点：基于软件的功能性需求，是系统功能的抽象结构表述，关注系统提供给最终用户的功能。 （2）Development View（开发视图）Development View（开发视图）：考虑开发技术、过程与组织，刻画系统的开发管理结构模型。 视角：软件的开发实现； 关注点：是软件体系结构的逻辑视图在具体实现阶段的表示，关注软件实现的技术与组织管理要求及约束。 （3）Process View（进程视图）Process View（进程视图）：刻画系统的运行时的结构模型。 视角：软件运行时(Run-time)的结构形态； 关注点：基于软件的非功能性需求，是软件系统运行时的动态结构，关注的是系统非功能性需求的满足。 （4）Physical View（物理视图）Physical View（物理视图）：逻辑视图中的各功能构件在安装部署环境中的映射，刻画系统的安装部署结构模型。 视角：软件在实际安装部署环境中的结构形态； 关注点：基于软件的非功能性需求，是软件系统安装运行时的动态结构，关注的是系统非功能性需求的满足。 （5）Scenarios View（场景视图）Scenarios View（场景视图）：从系统使用的角度对系统结构的描述。它反映的是在完成一个系统功能时，系统各功能构件间的交互关系。 视角：用户视角； 关注点：基于软件的功能性需求，关注的是在完成一个系统功能时，系统各功能构件间的协作关系，增加设计的可理解性，为其它视图的分析设计服务。 （四）典型的软件体系结构风格 一、管道-过滤器体系结构风格 (Pipe-Filter Style)：构件类型: 过滤器（Filter），数据处理构件 连接件类型: 管道（Pipe），过滤器间的连接件 每个处理步骤封装在一个过滤器构件中 数据通过过滤器之间的管道传输 重组过滤器可以建立相关的系统族（不同数据处理顺序或功能） 逻辑视图： 系统输入：文本文件，其他的数据源(Data Source) 系统输出：数据宿/数据池（Data Sink） 管道：负责实现相邻步骤之间的数据流动 过滤器：数据流的独立处理构件，负责丰富、提炼或转换它的输入数据 过滤器的工作方式： 【被动过滤器（Passive Filter）】 过滤器从前一个过滤器或数据源中拉出（pull）数据 过滤器把输出数据压入（push）后一个过滤器或数据池（Data Sink） 【主动过滤器（Active Filter）】 过滤器以循环的方式工作，从前一个过滤器或数据源拉出输入数据并将其输出数据压入下一个过滤器或数据池（Data Sink） 管道(Pipe)： 表示过滤器之间的连接；数据源和第一个过滤器之间的连接；以及最后的过滤器和data sink之间的连接 如果管道连接两个主动过滤器,那么管道需要迚行缓冲和同步 管道可以实现数据在过滤器之间的数据转换，将一个过滤器的输出数据格式转换为其后接的过滤器的数据输入格式 应用场景（Context）： 处理或者转换输入数据流 对数据的处理可以容易地分成几个处理步骤 系统的升级要求可以通过替换/增加/重组处理步骤实现，有时甚至由使用者完成操作 不同的处理步骤间不共享信息 优点： 高内聚和低耦合 支持过滤器配置实现可扩展性/可伸缩性（Flexibility） 支持过滤器构件的重用 有利于系统的维护与演化更新（Evolution） 可支持局部的并行处理以提高效率 缺点： 增量式处理数据时，存在效率问题 数据格式转换的问题：数据转换额外开销 不适合交互式应用系统 二、基于事件的隐式调用风格 (Event-Based Implicit Invocation Style)又称：事件驱动架构（Event Driven Architecture, EDA） 显式调用（直接耦合） 构件之间的交互是建立在彼此知道对方端口 构件的交互是固定的、预先设计的 隐式调用（间接耦合） 构件间的交互不是固定的、预先未知 构件间交互无需彼此感知（不知道对方的端口） 采用离散、异步的事件机制实现系统的构件间的松散、间接耦合的交互： 系统预先设计定义一套事件主题（Event Scheme） 系统中的其它构件预先注册一个或多个事件主题 系统中的某个构件触发一个或多个事件 当一个事件被触发，系统将事件发布给事先注册了该事件主题的所有构件 这样，某个构件上的一个或多个事件的触发就导致了系统中其它构件对事件的响应 构件类型: 事件源(Event Source)、事件处理者(Event Handler)、事件分发者(Event Dispatcher) 连接件类型：事件（Event）机制 应用场景（Context）：适用于异步、并发性的系统 对事件的处理顺序无要求的系统 事件的处理要求具有很好的灵活性 非集中式控制的软件系统 优点： 系统具有很好的灵活性，系统易于伸缩扩展 缺点： 系统控制权的问题：无中心控制系统 数据的交换问题：一些情况下，基于事件的系统必须依靠一个共享的仓库进行交互。在这些情况下，全局性能和资源管理便成了问题。 事件处理顺序控制问题 三、分层体系结构风格 (Layered Style)应用场景（Context）： 一个需要分解的大系统 系统的显著特征是混合了低层与高层问题 系统的需求本身定义了多个层次上的需求 系统规格说明描述了高层任务，并希望可移植性 高层任务到平台的映射不是直接的 系统需要满足以下非功能性特性： 后期源代码的改动应该不影响到整个系统 系统的各个部分应该可以替换。构件应该可以有不同的实现而不影响其他的构件 提高构件的内聚性 复杂构件的进一步分解 设计和开发系统时，工作界限必须清楚 优点： 层的可重用性 标准化的支持 局部依赖特性 可替换性 缺点： 层间的依赖性 当对低层的修改由于某种原因影响了高层的时候，可能引起底层之上的多个层次 效率问题：过多的层次造成从最上层到最下层需要进行逐层的交互等 四、仓库风格 (Repository Style)以数据为中心（Data-Center）的体系结构风格 数据中心定义了一种共享的数据结构 构件之间通过数据中心分布式协同工作 构件类型：独立构件（Independent Component）、 仲裁者（Mediator） 连接件类型：仓库（Repository） 两种类型： 被动仓库：Database（数据库），由独立构件访问存取仓库来驱动系统运行 主动仓库：Blackboard（黑板），由仓库的数据或状态来触发独立构件做相应的处理，驱动系统运行 优点： 便于多构件间共享大量数据，而不必关心数据是何时产生的、由谁提供的，以及通过何种途径来提供 便于将新的构件作为知识源添加到系统中来（Blackboard风格） 缺点： 共享数据结构的修改变得非常困难 需要同步机制和加锁机制来保证共享数据的完整性和一致性，增大了系统设计的复杂度 （五）GRASP GRASP General Responsibility Assignment Software Principles 通用职责分配软件原则 核心思想：职责分配（Responsibility Assignment） 9个基本原则： 信息与家(Information expert) 创建者(Creator) 高内聚(High Cohesion) 低耦合(Low Coupling) 控制者(Controller) 多态（Polymorphism） 纯虚构（Pure Fabrication） 间接性（Indirection） 变化预防（Protected Variations） （六）创建型设计模式（Creational Patterns） 一、工厂方法模式（Factory Method）为某一个产品族对象的创建，定义统一的Factory Method接口，并由子类具体实现对象创建。 （1）Context(应用场景) 当一个类不知道它所需要的对象的类时：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可 当一个类希望通过其子类来指定创建对象时：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中 （2）参与者 抽象产品类 Product 具体产品类 ConcreteProduct 抽象工厂类 Creator 具体工厂类 ConcreteCreator （3）优点 为一组相关或相似对象（产品族）的创建提供了统一的创建接口（工厂方法） 将产品族对象与使用者（Client）之间解耦，使用者无需了解产品族对象创建知识就可获得和使用产品族对象 （4）缺点需要抽象工厂类和其相应的子类作为工厂方法的定义和实现，如果设计确实需要抽象工厂类和子类存在，则很好；否则的话，需要增加抽象工厂类与其子类 二、抽象工厂模式（Abstract Factory）解决多个产品族对象的创建工作，专门定义一个用于创建这些对象的接口(基类)。客户只需与这个基接口打交道，不必考虑实体类的类型 （1）Context(应用场景) 一个系统不要求依赖产品类实例如何被创建、组合和表达 这个系统有多个系列产品，而系统中只消费其中某一系列产品 系统要求提供一个产品类的库，所有产品以同样的接口出现，客户端不需要依赖具体实现 （2）参与者 抽象产品族（Abstract Product） 抽象产品（Product） 具体产品（Concrete Product） 抽象工厂（Factory） 具体工厂（Concrete Factory） （3）优点 Concrete Factory中的工厂方法把产品对象创建封装起来，并将具体的产品类与Client分离 保证产品族对象创建接口的一致性（统一的产品族对象创建接口） （4）缺点Concrete Factory对象的工厂方法数目对应product种类数目，增加新的product种类比较困难，要影响到factory的基类，进而影响到所有的子类 三、原型模式（Prototype）以一个已有的对象作为原型，通过它来创建新的对象。在增加新的对象的时候，新对象的细节创建工作由自己来负责，从而使新对象的创建过程与Client隔离开来 （1）Context(应用场景) 当产品的创建过程要独立于系统时 当产品的类型是在运行时被指定的情况下 避免创建一个与product层次平行的factory层次时 当产品类的实例只能是几种确定的不同实例状态中的一种 （2）参与者 原型类（Prototype） 具体原型类（ConcretePrototype） 用户类（Client） . 四、单例模式（Singleton）确保1个类只有1个实例化对象，提供一个全局访问点 （1）Context(应用场景) 类必须只有一个实例，并且必须可以从已知的访问点对客户端进行访问 当唯一的实例应该通过子类进行扩展时，客户机应该能够在不修改代码的情况下使用扩展实例 （2）参与者单例类（Singleton） . （3）评价： 提供了一种全局化的单一对象实例设计方法 在单态设计模式基础上，可扩展设计受限数目的对象实例创建 五、小结 工厂方法模式Factory Method：通过一个一致化的factory method完成产品对象的创建 抽象工厂模式Abstract Factory：基于多个factory method实现多个product族对象的创建 原型模式Prototype：通过product原型来clone创建product对象 建造者模式Builder：完成一个包含多个子对象的复合对象的构造 单例模式Singleton：Product类的单对象实例创建 Finder：把对象的获取过程与客户隔离开 （七）结构型设计模式（Structural Patterns） 一、适配器模式（Adapter）定义一个包装类，用于包装不兼容接口的对象 （1）作用把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作 （2）Context(应用场景) 系统需要复用现有类，而该类的接口不符合系统的需求，可以使用适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作 多个组件功能类似，但接口不统一且可能会经常切换时，可使用适配器模式，使得客户端可以以统一的接口使用它们 （3）参与者 适配器 Adapter 适配者 Adaptee 客户类 Client 目标类 Target （4）优点更好的复用性；透明、简单；更好的扩展性；解耦性；符合开放-关闭原则 （5）缺点过多的使用适配器，会让系统非常零乱，不易整体进行把握 （6）分类1.类的适配器模式 class adapterAdapter与Adaptee是继承关系 无法适配Adaptee的子类 可以重载Adaptee的行为 2.对象的适配器模式 object adapterAdapter与Adaptee是委派关系 可以适配Adaptee的所有子类 二、组合模式（Composite）将对象组合到树结构中以表示部分-整体层次结构。Composite允许客户端统一地处理单个对象和对象的组合 （1）参与者Client, Component, Leaf, Composite （3）Context(应用场景) 表示对象的部分-整体层次结构 希望用户忽略组合对象与单个对象的不同，用户将统一地使用组合结构中的所有对象 （4）优点 定义了包含leaf对象和composite对象的类层次接口——递归结构 客户一致地处理复合对象和单个对象 易于增加新类型的组件 （5）缺点很难限制组合中的组件：有时你希望一个组合只能有某些特定的组件。使用Composite时，你不能依赖类型系统施加这些约束，而必须在运行时刻进行检查 三、小结 Adapter：用于两个不兼容接口之间的转接 Bridge：用于将接口的抽象与多个可能的实现连接起来 Facade：用于为复杂的子系统定义一个新的简单易用的接口 Composite：用于构造对象组合结构 Decorator：用于为对象增加新的职责（修改对象的接口） Proxy：为目标对象提供一个代理者 Flyweight：针对细粒度对象的一种全局控制手段。 （八）行为型设计模式（Behavioral Patterns） 一、命令模式（Command）将请求封装为对象，从而允许您用不同的请求、队列或日志请求参数化客户机，并支持可撤消操作 （1）Context(应用场景) 需要封装表示对象间的调用交互 需要实现对象间交互调用的管理 需要支持对象间交互调用的undo/redo 记录对象间交互调用以便系统回滚 需保证对象间交互的事务完整性 （2）评价 对象间调用交互的解耦 支持对象间交互的redo/undo – 调用重用 组合对象间的多个调用交互–宏调用/批处理 易扩展对象间交互–通过继承定义新的Command对象 . 二、迭代器模式（Iterator）用于支持集合对象的遍历操作，而无需暴露集合对象的内部表示 （1）Context(应用场景) 访问集合对象而无需暴露其内部存储结构 可提供多种遍历操作方法 为不同遍历操作方法提供一个统一的接口形式 （2）参与者 迭代器（Iterator） 具体迭代器（ConcreteIterator） 集合（Aggregate） 具体集合（ConcreteAggregate） （3）评价 支持多种集合遍历 迭代器简化了集合接口 一个集合上可以有多种遍历 三、观察者模式（Observer）支持对象间1对多的交互调用方式 （1）Context(应用场景) 当一个抽象有两个方面，一个依赖于另一个时。将这些方面封装在单独的对象中，可以独立地改变和重用它们 当一个对象的更改需要更改其他对象，而您不知道需要更改多少对象时 当一个对象应该能够通知其他对象而不需要假设这些对象是谁。换句话说，您不希望这些对象紧密耦合 （2）参与者 Subject: 目标 ConcreteSubject: 具体目标 Observer: 观察者 ConcreteObserver: 具体观察者 （3）评价 抽象目标与观察者之间的耦合 支持广播 意想不到的更新 四、小结 Strategy、Iterator、Mediator、State、Command：用一个对象来封装某些特性，比如变化、交互、状态、行为、命令 Observer：建立起subject和observer之间的松耦合连接 Mediator：把约束限制集中起来，中心控制 Command：侧重于命令的总体管理 Chain of Responsibility：侧重于命令被正确处理 Interpreter用于复合结构中操作的执行过程","categories":[],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"https://flowermushroom.github.io/tags/设计模式/"}]},{"title":"计算机图形学学习笔记（一）：计算机图形学概述","slug":"计算机图形学学习笔记（一）：计算机图形学概述","date":"2018-12-16T03:57:00.000Z","updated":"2019-07-27T10:04:26.026Z","comments":true,"path":"2018/12/16/计算机图形学学习笔记（一）：计算机图形学概述/","link":"","permalink":"https://flowermushroom.github.io/2018/12/16/计算机图形学学习笔记（一）：计算机图形学概述/","excerpt":"","text":"重点：掌握计算机图形学研究的内容、应用领域以及图形硬件和软件系统。 难点：理解光栅扫描显示器的工作原理以及彩色显示机理。 1.1 研究内容（1）什么是计算机图形学ISO的定义：计算机图形学是研究通过计算机将数据转换为图形，并在专门的显示设备上显示的原理、方法和技术的学科。 （2）计算机图形学研究的内容1. 图形的输入如何开发利用图形输入设备及软件将图形输入到计算机中去，以便作各种处理。 2. 图形的处理包括对图形进行变换（几何变换，投影变换）和运算（集合运算），着色，形变等… … 3.图形的输出如何将图形特定的表示形式转换成图形输出系统便于接受的表示形式，并将图形在显示屏或打印机等输出设备上输出 （3）计算机中表示图的方法1.点阵表示简称为图像（Image）：枚举出图形中所有的点 2.参数表示简称为图形（Graphics）：用图形的形状参数（方程或分析表达式的系数，线段的端点坐标等）和属性参数（颜色、线型等）来表示图形 （4）图形与图像1. 图像图像纯指计算机内以位图(Bitmap)形式存在的灰度信息。 2. 图形图形含有几何属性，更强调场景的几何表示，是由场景的几何模型和景物的物理属性共同组成的。 图形主要分为两类： 基于线条信息表示（如工程图、等高线地图、曲面的线框图等） 明暗图(Shading) （如：真实感图形） 1.2 发展历史近二十年中，国际标准化组织ISO已经批准和正在讨论的与计算机图形有关的标准有：GKS、GKS-3D、PHIGS、CGM、CGI、IGES、STEP 事实标准：SGI的OpenGL，微软的Direct X，Adobe的Postscript等 1.3 图形显示设备（1）图形显示和图形绘制图形输出包括图形的显示和图形的绘制 图形显示：指的是在屏幕上输出图形 图形绘制：通常指把图形画在纸上，也称硬拷贝，打印机和绘图仪是两种最常用的硬拷贝设备 （2）阴极射线管(CRT, Cathode-Ray Tube)1. 组成 电子枪：电子枪由电灯丝，阴极和控制栅组成。电流通过灯丝产生热量，对阴极加热使其发射出电子束 聚焦系统：聚焦系统是一个电透镜，能使众多的电子聚集于一点 加速系统：加速阳极使电子达到轰击激发荧光屏应有的速度 磁偏转系统：偏转系统是使用静电场或磁场控制电子束产生偏转，最大偏转角是衡量系统性能的最重要的指标，显示器长短与此有关CRT显示器屏幕越大整个显象管就越长） 荧光屏：荧光屏是最终显示图形的部件 2.工作原理 高速的电子束由电子枪发出，经过聚焦系统、加速系统和磁偏转系统就会到达荧光屏的特定位置。电子束轰击到荧光屏的不同部位，被其内表面的荧光物质吸收，发光产生可见的图形 荧光物质受电子束一次轰击之后发光，亮度会迅速衰减，所以要保持显示一幅稳定的画面，必须不断地发射电子束（不断刷新） 3. 相关概念[1] 刷新刷新频率：每秒钟重绘屏幕的次数。 刷新一次是指电子束从上到下扫描一次的过程 刷新频率高到一定值后，图象才能稳定显示 隔行扫描与逐行扫描 只有刷新频率高到一定值后，图象才能稳定显示。大约达到每秒60帧即60Hz时，人眼才能感觉到屏幕不闪烁，要使人眼觉得舒服，一般必须有85Hz以上的刷新频率。 [2] 像素(Pixel)构成屏幕（图像）的最小元素 [3] 分辨率(Resolution)CRT在水平或竖直方向单位长度上能识别的最大像素个数，即水平和垂直方向上每厘米可绘制的点数. 单位：通常为dpi（dots per inch) 在假定屏幕尺寸一定的情况下，也可用整个屏幕所能容纳的像素个数描述，如：640 * 480，800 * 600，1024 * 768, 1280 * 1024 等等 分辨率主要取决于CRT所用的荧光物质的类型、聚焦系统和偏转系统 （3）彩色阴极射线管通过将能发不同颜色的光的荧光物质进行组合而产生彩色 1. 原理 彩色CRT显示器的荧光屏上涂有三种荧光物质，它们分别能发红、绿、兰三种颜色的光。而电子枪也发出三束电子束来激发这三种物质，中间通过一个控制栅格（荫罩，又称影孔板）来决定三束电子到达的位置。 三束电子经过荫罩的选择，分别到达三个荧光点的位置。通过控制三个电子束的强弱就能控制屏幕上点的颜色。 2. 显示器能同时显示的颜色个数如果每支电子枪发出的电子束的强度有256个等级，则显示器能同时显示 256 * 256 * 256 = 16M 种颜色，称为真彩系统。 （4）随机扫描显示器随机扫描显示器中，电子束可以在任意方向上自由移动，按照显示命令用画线的方式绘出图形，因此也称矢量显示器。 1. 特点电子束随意移动，只扫描荧屏上要显示的部分。 2. 工作原理 应用程序输入并与图形软件一起存放在系统内存中 应用程序的图形命令由图形软件包翻译成显示文件并存入刷新存储器 (显示缓存） 由显示处理器访问这个显示文件以刷新屏幕 在每个刷新周期内，显示处理器遍历一次显示文件程序中的每条命令 （5）光栅扫描显示器1.相关概念[1] 扫描线（Scan Line）电子束先从荧光屏的左上角开始，向右扫描一条水平线 [2] 帧（Frame）一次扫描所产生的图像称为一帧 [3] 水平回扫期 (horizontal retrace)电子束在扫描线之间的回扫期 [4] 垂直回扫期 (Vertical retrace)在帧之间的回扫期 2. 绘图过程对光栅扫描显示器来说，当电子束扫描到该显示图形的点时，其强度发生变化，使该位置的亮度与背景亮度不同，这样便能够显示出要绘制的图形 3. 显示器的分辨率电子束按固定的扫描顺序进行扫描N条扫描线，每条扫描线有M个像素，显示器的分辨率则为M * N （6）光栅图形显示系统1. 组成 显示处理器（Display Processor） 其主要任务是将应用程序定义为一组像素强度值,存放在帧缓冲存储器（扫描转换），同时也能执行某些附加的操作几何变换、裁剪、纹理映射等等。 帧缓冲存储器（Frame Buffer） 简称帧缓冲器，俗称显存，保存了对应屏幕所有点的亮度值。 视频控制器（Video Controller） 建立帧缓存与屏幕像素之间的一一对应，负责刷新。 CRT 2. 优点 成本低 易于绘制填充图形 色彩丰富 刷新频率一定，与图形的复杂程度无关 易于修改图形 3. 缺点 需要扫描转换 会产生走样 （7）单色显示系统 帧缓存中单元数目与显示器上像素的数目相同，单元与像素一一对应。各单元的数值决定了其对应像素的颜色。 显示颜色的种类与帧缓存中每个单元的位数有关（图示帧缓冲器的每个单元只有一位）。 （8）显存相关的问题1. 帧缓存与显示器分辨率的关系帧缓存的大小 = 显示器分辨率的大小 * 帧缓存的位平面数 / 8 2. 高分辨率和真彩要求有大的显存[1]采用查色表（Lookup Table）机制又称彩色表（Color Table）机制 查色表：查色表是一维线性表，其每一项的内容对应一种颜色，它的长度由帧缓存单元的位数决定，例如：每单元有8位，则查色表的长度为 2 ^ 8＝256 目的：在帧缓存单元的位数不增加的情况下，具有大范围内挑选颜色的能力。帧缓冲器各单元保存的不是相应像素的颜色值，而是查色表各项的索引值，按照这个索引值在彩色表中取出红、绿、蓝三种颜色的分量，然后送CRT显示器对该象素进行颜色显示。 [2]采用隔行扫描的方法隔行扫描：把一帧分两场，即奇数场与偶数场 一场 1/60s，场频 60HZ，帧频 30HZ 第一趟：电子束从顶到底，一行隔一行地扫描。 第二趟：垂直回扫后，电子束则再扫描另一半扫描线。 以这种方式的隔行扫描使在逐行扫描所需时间的一半时就能看就能看到整个屏幕显示。 画面更新频率仍为60HZ，降低了闪烁效应，每一场1/60秒内，帧缓存中数据量比逐行扫描少一半。降低了视频控制器存取帧缓存的速度及传输带宽的要求。","categories":[],"tags":[{"name":"图形学","slug":"图形学","permalink":"https://flowermushroom.github.io/tags/图形学/"}]}]}